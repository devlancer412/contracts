{
  "language": "Solidity",
  "sources": {
    "contracts/affiliate/Affiliate.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {Auth} from \"../utils/Auth.sol\";\nimport {TrackableProxy} from \"../utils/proxy/TrackableProxy.sol\";\n\ncontract Affiliate is TrackableProxy, Auth {\n  // redeem token address\n  address public erc20token;\n  // shows redeemed if true => redeemed else not redeemed\n  mapping(uint64 => uint256) public rewardsRedeem;\n  // reward distributor\n  address public rewardsDistributor;\n\n  event Redeem(address indexed redeemer, uint64[] redeem_codes, uint256 redeemed_value);\n  event EggPurcharsed(address indexed affiliate, uint256 amount);\n\n  struct Sig {\n    bytes32 r;\n    bytes32 s;\n    uint8 v;\n  }\n\n  // constructor\n  constructor(address _erc20token, address _rewardsDistributor) {\n    erc20token = _erc20token;\n    rewardsDistributor = _rewardsDistributor;\n  }\n\n  // redeem parameter validate function\n  function _validRedeemParam(\n    address redeemer,\n    uint64[] calldata redeem_codes,\n    uint256 totalValue,\n    Sig calldata signature\n  ) private view returns (bool) {\n    bytes32 messageHash = keccak256(\n      abi.encodePacked(msg.sender, redeemer, redeem_codes, totalValue)\n    );\n    bytes32 ethSignedMessageHash = keccak256(\n      abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", messageHash)\n    );\n\n    return\n      hasRole(\n        \"DISTRIBUTOR\",\n        ecrecover(ethSignedMessageHash, signature.v, signature.r, signature.s)\n      );\n  }\n\n  // funciton\n  // @param   redeemer: affiliates receiving rewards.\n  // @param   redeem_codes: array of redeem code\n  // @param   values: array of reward value\n  // @param   signature: signature of distributor\n  function redeemCode(\n    address redeemer,\n    uint64[] calldata redeem_codes,\n    uint256 totalValue,\n    Sig calldata signature\n  ) public {\n    //  keccak256(abi.encodePacked(address, redeem_codes, values)) and make sure that the result of ECRECOVER is rewardsDistributor\n    require(\n      _validRedeemParam(redeemer, redeem_codes, totalValue, signature),\n      \"Affiliate:SIGNER_NOT_VALID\"\n    );\n\n    for (uint256 i = 0; i < redeem_codes.length; i++) {\n      require(\n        (rewardsRedeem[redeem_codes[i] / 256] & (1 << (redeem_codes[i] % 256))) == 0,\n        \"Affiliate:ALREADY_REDEEMED\"\n      );\n      rewardsRedeem[redeem_codes[i] / 256] += (1 << (redeem_codes[i] % 256));\n    }\n\n    IERC20(erc20token).transferFrom(rewardsDistributor, redeemer, totalValue);\n    emit Redeem(redeemer, redeem_codes, totalValue);\n  }\n\n  // function\n  // @param   code: redeem code\n  // @return  if redeemed return true else return false\n  function redeemed(uint64 code) public view returns (bool) {\n    return (rewardsRedeem[code / 256] & (1 << (code % 256))) != 0;\n  }\n\n  function setDistributor(address _address) public onlyOwner {\n    rewardsDistributor = _address;\n  }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/utils/Auth.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.9;\n\nlibrary Strings {\n  function toBytes32(string memory text) internal pure returns (bytes32) {\n    return bytes32(bytes(text));\n  }\n\n  function toString(bytes32 text) internal pure returns (string memory) {\n    return string(abi.encodePacked(text));\n  }\n}\n\ncontract Auth {\n  //Address of current owner\n  address public owner;\n  //Address of new owner (Note: new owner must pull to be an owner)\n  address public newOwner;\n  //If paused or not\n  uint256 private _paused;\n  //Roles mapping (role => address => has role)\n  mapping(bytes32 => mapping(address => bool)) private _roles;\n\n  //Fires when a new owner is pushed\n  event OwnerPushed(address indexed pushedOwner);\n  //Fires when new owner pulled\n  event OwnerPulled(address indexed previousOwner, address indexed newOwner);\n  //Fires when account is granted role\n  event RoleGranted(string indexed role, address indexed account, address indexed sender);\n  //Fires when accoount is revoked role\n  event RoleRevoked(string indexed role, address indexed account, address indexed sender);\n  //Fires when pause is triggered by account\n  event Paused(address account);\n  //Fires when pause is lifted by account\n  event Unpaused(address account);\n\n  error Unauthorized(string role, address user);\n  error IsPaused();\n  error NotPaused();\n\n  constructor() {\n    owner = msg.sender;\n    emit OwnerPulled(address(0), msg.sender);\n  }\n\n  modifier whenNotPaused() {\n    if (paused()) revert IsPaused();\n    _;\n  }\n\n  modifier whenPaused() {\n    if (!paused()) revert NotPaused();\n    _;\n  }\n\n  modifier onlyOwner() {\n    if (msg.sender != owner) revert Unauthorized(\"OWNER\", msg.sender);\n    _;\n  }\n\n  modifier onlyRole(string memory role) {\n    if (!hasRole(role, msg.sender)) revert Unauthorized(role, msg.sender);\n    _;\n  }\n\n  function hasRole(string memory role, address account) public view virtual returns (bool) {\n    return _roles[Strings.toBytes32(role)][account];\n  }\n\n  function paused() public view virtual returns (bool) {\n    return _paused == 1 ? true : false;\n  }\n\n  function pushOwner(address account) public virtual onlyOwner {\n    require(account != address(0), \"No address(0)\");\n    require(account != owner, \"Only new owner\");\n    newOwner = account;\n    emit OwnerPushed(account);\n  }\n\n  function pullOwner() public virtual {\n    if (msg.sender != newOwner) revert Unauthorized(\"NEW_OWNER\", msg.sender);\n    address oldOwner = owner;\n    owner = msg.sender;\n    emit OwnerPulled(oldOwner, msg.sender);\n  }\n\n  function grantRole(string memory role, address account) public virtual onlyOwner {\n    require(bytes(role).length > 0, \"Role not given\");\n    require(account != address(0), \"No address(0)\");\n    _grantRole(role, account);\n  }\n\n  function revokeRole(string memory role, address account) public virtual onlyOwner {\n    require(hasRole(role, account), \"Role not granted\");\n    _revokeRole(role, account);\n  }\n\n  function renounceRole(string memory role) public virtual {\n    require(hasRole(role, msg.sender), \"Role not granted\");\n    _revokeRole(role, msg.sender);\n  }\n\n  function pause() public virtual onlyRole(\"PAUSER\") whenNotPaused {\n    _paused = 1;\n    emit Paused(msg.sender);\n  }\n\n  function unpause() public virtual onlyRole(\"PAUSER\") whenPaused {\n    _paused = 0;\n    emit Unpaused(msg.sender);\n  }\n\n  function _grantRole(string memory role, address account) internal virtual {\n    if (!hasRole(role, account)) {\n      bytes32 encodedRole = Strings.toBytes32(role);\n      _roles[encodedRole][account] = true;\n      emit RoleGranted(role, account, msg.sender);\n    }\n  }\n\n  function _revokeRole(string memory role, address account) internal virtual {\n    bytes32 encodedRole = Strings.toBytes32(role);\n    _roles[encodedRole][account] = false;\n    emit RoleRevoked(role, account, msg.sender);\n  }\n}\n"
    },
    "contracts/utils/proxy/TrackableProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/Proxy.sol)\n\npragma solidity ^0.8.9;\n\ncontract TrackableProxy {\n  constructor() {}\n\n  function _fallback() internal {\n    bytes32 _id = keccak256(abi.encode(\"Purchase(address indexed, address indexed, uint256)\"));\n    assembly {\n      // Copy msg.data. We take full control of memory in this inline assembly\n      // block because it will not return to Solidity code. We overwrite the\n      // Solidity scratch pad at memory position 0.\n      let dataPtr := 0xc0 // next call data pointer\n      let paramNumber := div(sub(calldatasize(), 0x64), 0x20) // get reall call parameter number\n      calldatacopy(add(dataPtr, 0x24), 0x04, mul(paramNumber, 0x20)) // copy call params\n      calldatacopy(0x60, add(mul(paramNumber, 0x20), 0x04), 0x40) // capy distination and affiliate address\n      calldatacopy(dataPtr, add(mul(paramNumber, 0x20), 0x60), 0x04) // copy function selector\n      mstore(add(dataPtr, 0x04), caller()) // sent msg.sender to first param\n      let to := mload(0x60) // load distination address\n      let affiliate := mload(0x80) // load affiliate address\n\n      // Call the implementation.\n      // out and outsize are 0 because we don't know the size yet.\n      let result := call(gas(), to, callvalue(), dataPtr, add(mul(paramNumber, 0x20), 0x24), 0, 0)\n\n      // emit log\n      log3(add(dataPtr, add(mul(paramNumber, 0x20), 0x04)), 0x20, _id, affiliate, to)\n      // Copy the returned data.\n      returndatacopy(0, 0, returndatasize())\n\n      switch result\n      // delegatecall returns 0 on error.\n      case 0 {\n        revert(0, returndatasize())\n      }\n      default {\n        return(0, returndatasize())\n      }\n    }\n  }\n\n  /**\n   * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n   * function in the contract matches the call data.\n   */\n  fallback() external payable {\n    _fallback();\n  }\n\n  /**\n   * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n   * is empty.\n   */\n  receive() external payable {\n    _fallback();\n  }\n}\n"
    },
    "contracts/rooster/RoosterMetadata.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.9;\n\nimport {ERC721} from \"@rari-capital/solmate/src/tokens/ERC721.sol\";\nimport {Strings} from \"@openzeppelin/contracts/utils/Strings.sol\";\nimport {Auth} from \"../utils/Auth.sol\";\n\nabstract contract RoosterMetadata is ERC721, Auth {\n  using Strings for uint256;\n\n  //Rooster metadata base uri\n  string private _baseUri;\n  //Maps rooster id to breed\n  mapping(uint256 => uint256) private _breeds;\n\n  //Fires when base uri is updated\n  event UpdateBaseUri(string baseUri);\n  //Fires when breed is set\n  event BreedSet(uint256 indexed roosterId, uint256 breed);\n\n  function breeds(uint256 roosterId) public view returns (uint256) {\n    require(_exists(roosterId), \"Query for nonexistent rooster\");\n    return _breeds[roosterId];\n  }\n\n  function tokenURI(uint256 roosterId) public view override returns (string memory) {\n    require(_exists(roosterId), \"Query for nonexistent rooster\");\n    return string(abi.encodePacked(_baseUri, roosterId.toString()));\n  }\n\n  function setBaseUri(string memory newUri) public onlyOwner {\n    _baseUri = newUri;\n    emit UpdateBaseUri(newUri);\n  }\n\n  function _setBreed(uint256 roosterId, uint256 breed) internal {\n    _breeds[roosterId] = breed;\n    emit BreedSet(roosterId, breed);\n  }\n\n  function _exists(uint256 tokenId) internal view virtual returns (bool) {\n    return ownerOf[tokenId] != address(0);\n  }\n}\n"
    },
    "@rari-capital/solmate/src/tokens/ERC721.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\n/// @dev Note that balanceOf does not revert if passed the zero address, in defiance of the ERC.\nabstract contract ERC721 {\n    /*///////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /*///////////////////////////////////////////////////////////////\n                          METADATA STORAGE/LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n\n    /*///////////////////////////////////////////////////////////////\n                            ERC721 STORAGE                        \n    //////////////////////////////////////////////////////////////*/\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(uint256 => address) public ownerOf;\n\n    mapping(uint256 => address) public getApproved;\n\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n    /*///////////////////////////////////////////////////////////////\n                              CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC721 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 id) public virtual {\n        address owner = ownerOf[id];\n\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \"NOT_AUTHORIZED\");\n\n        getApproved[id] = spender;\n\n        emit Approval(owner, spender, id);\n    }\n\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == ownerOf[id], \"WRONG_FROM\");\n\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(\n            msg.sender == from || msg.sender == getApproved[id] || isApprovedForAll[from][msg.sender],\n            \"NOT_AUTHORIZED\"\n        );\n\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        unchecked {\n            balanceOf[from]--;\n\n            balanceOf[to]++;\n        }\n\n        ownerOf[id] = to;\n\n        delete getApproved[id];\n\n        emit Transfer(from, to, id);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes memory data\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 interfaceId) public pure virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                       INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(ownerOf[id] == address(0), \"ALREADY_MINTED\");\n\n        // Counter overflow is incredibly unrealistic.\n        unchecked {\n            balanceOf[to]++;\n        }\n\n        ownerOf[id] = to;\n\n        emit Transfer(address(0), to, id);\n    }\n\n    function _burn(uint256 id) internal virtual {\n        address owner = ownerOf[id];\n\n        require(ownerOf[id] != address(0), \"NOT_MINTED\");\n\n        // Ownership check above ensures no underflow.\n        unchecked {\n            balanceOf[owner]--;\n        }\n\n        delete ownerOf[id];\n\n        delete getApproved[id];\n\n        emit Transfer(owner, address(0), id);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                       INTERNAL SAFE MINT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function _safeMint(\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n}\n\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\ninterface ERC721TokenReceiver {\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 id,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return tryRecover(hash, r, vs);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/draft-EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/draft-EIP712.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ECDSA.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n */\nabstract contract EIP712 {\n    /* solhint-disable var-name-mixedcase */\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\n    uint256 private immutable _CACHED_CHAIN_ID;\n    address private immutable _CACHED_THIS;\n\n    bytes32 private immutable _HASHED_NAME;\n    bytes32 private immutable _HASHED_VERSION;\n    bytes32 private immutable _TYPE_HASH;\n\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        bytes32 typeHash = keccak256(\n            \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        );\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n        _CACHED_CHAIN_ID = block.chainid;\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\n        _CACHED_THIS = address(this);\n        _TYPE_HASH = typeHash;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (address(this) == _CACHED_THIS && block.chainid == _CACHED_CHAIN_ID) {\n            return _CACHED_DOMAIN_SEPARATOR;\n        } else {\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n        }\n    }\n\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 nameHash,\n        bytes32 versionHash\n    ) private view returns (bytes32) {\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-ERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./draft-IERC20Permit.sol\";\nimport \"../ERC20.sol\";\nimport \"../../../utils/cryptography/draft-EIP712.sol\";\nimport \"../../../utils/cryptography/ECDSA.sol\";\nimport \"../../../utils/Counters.sol\";\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * _Available since v3.4._\n */\nabstract contract ERC20Permit is ERC20, IERC20Permit, EIP712 {\n    using Counters for Counters.Counter;\n\n    mapping(address => Counters.Counter) private _nonces;\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private immutable _PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    constructor(string memory name) EIP712(name, \"1\") {}\n\n    /**\n     * @dev See {IERC20Permit-permit}.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\n\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSA.recover(hash, v, r, s);\n        require(signer == owner, \"ERC20Permit: invalid signature\");\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @dev See {IERC20Permit-nonces}.\n     */\n    function nonces(address owner) public view virtual override returns (uint256) {\n        return _nonces[owner].current();\n    }\n\n    /**\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /**\n     * @dev \"Consume a nonce\": return the current value and increment.\n     *\n     * _Available since v4.1._\n     */\n    function _useNonce(address owner) internal virtual returns (uint256 current) {\n        Counters.Counter storage nonce = _nonces[owner];\n        current = nonce.current();\n        nonce.increment();\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, _allowances[owner][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = _allowances[owner][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Spend `amount` form the allowance of `owner` toward `spender`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/mocks/MockERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";\n\ncontract MockERC20 is ERC20Permit {\n  uint8 private immutable _decimals;\n\n  constructor(\n    string memory name_,\n    string memory symbol_,\n    uint8 decimals_\n  ) ERC20Permit(name_) ERC20(name_, symbol_) {\n    _decimals = decimals_;\n  }\n\n  function mint(address to, uint256 amount) external {\n    _mint(to, amount);\n  }\n\n  function burn(address from, uint256 amount) external {\n    _burn(from, amount);\n  }\n\n  function set(address account, uint256 amount) external {\n    _burn(account, balanceOf(account));\n    _mint(account, amount);\n  }\n\n  function decimals() public view override returns (uint8) {\n    return _decimals;\n  }\n}\n"
    },
    "contracts/mocks/Usdt.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\nimport {MockERC20} from \"./MockERC20.sol\";\n\ncontract MockUsdt is MockERC20 {\n  constructor() MockERC20(\"Tether USD\", \"USDT\", 6) {\n    _mint(msg.sender, 1_000_000e6);\n  }\n}\n"
    },
    "contracts/mocks/Usdc.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\nimport {MockERC20} from \"./MockERC20.sol\";\n\ncontract MockUsdc is MockERC20 {\n  constructor() MockERC20(\"USD Coin\", \"USDC\", 6) {\n    _mint(msg.sender, 1_000_000e6);\n  }\n}\n"
    },
    "contracts/mocks/Dai.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\nimport {MockERC20} from \"./MockERC20.sol\";\n\ncontract MockDai is MockERC20 {\n  constructor() MockERC20(\"Dai Stablecoin\", \"DAI\", 18) {\n    _mint(msg.sender, 1_000_000e6);\n  }\n}\n"
    },
    "contracts/store/Marketplace.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.9;\n\n/**\n  Marketplace spec: https://www.notion.so/RoosterWars-Marketplace-6350187ee37f4e239aa8441b7e634e00\n */\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\n\ncontract Marketplace is Ownable {\n  IERC20 public operatingToken;\n  uint256 public feeRate;\n\n  struct Listing {\n    address token;\n    uint256 tokenId;\n    uint256 price;\n    address owner;\n    bool fungible;\n    bool inactive;\n  }\n\n  uint256 public nextId;\n  // { listingId: Listing}\n  mapping(uint256 => Listing) public listings;\n  // { listingId: inStock }\n  mapping(uint256 => uint256) public stocks;\n  // { contractAddress: allowed }\n  mapping(address => bool) public allowedContracts;\n\n  event Listed(\n    uint256 listingId,\n    address indexed token,\n    uint256 indexed tokenId,\n    address indexed owner,\n    uint256 amount,\n    uint256 price,\n    bool fungible\n  );\n  event Live(uint256 listingId, uint256 price);\n  event Sold(uint256 listingId, address indexed owner, uint256 amount);\n  event Revoke(uint256 listingId);\n\n  constructor(IERC20 _operatingToken, uint256 _fee) {\n    operatingToken = _operatingToken;\n    feeRate = _fee;\n  }\n\n  function setAllowedToken(address tokenAddress, bool allowed) public onlyOwner {\n    allowedContracts[tokenAddress] = allowed;\n  }\n\n  function getListing(uint256 listingId)\n    public\n    view\n    returns (\n      address token,\n      uint256 tokenId,\n      uint256 price,\n      address owner,\n      bool fungible,\n      bool inactive\n    )\n  {\n    token = listings[listingId].token;\n    tokenId = listings[listingId].tokenId;\n    price = listings[listingId].price;\n    owner = listings[listingId].owner;\n    fungible = listings[listingId].fungible;\n    inactive = listings[listingId].inactive;\n  }\n\n  function onERC721Received(\n    address,\n    address,\n    uint256,\n    bytes calldata\n  ) public pure returns (bytes4) {\n    return this.onERC721Received.selector;\n  }\n\n  function onERC1155Received(\n    address,\n    address,\n    uint256,\n    uint256,\n    bytes calldata\n  ) public pure returns (bytes4) {\n    return this.onERC1155Received.selector;\n  }\n\n  function setFeeRate(uint256 _feeRate) public onlyOwner {\n    feeRate = _feeRate;\n  }\n\n  function restock(uint256 listingId, uint256 amount) public {\n    require(!listings[listingId].fungible, \"can only restock fungible tokens\");\n    require(listings[listingId].owner == msg.sender, \"not listing owner\");\n\n    IERC1155(listings[listingId].token).safeTransferFrom(\n      msg.sender,\n      address(this),\n      listings[listingId].tokenId,\n      amount,\n      \"\"\n    );\n    stocks[listingId] += amount;\n  }\n\n  function makeListing(\n    address token,\n    uint256 tokenId,\n    uint256 amount,\n    uint256 price,\n    bool fungible\n  ) public returns (uint256) {\n    nextId++;\n\n    if (fungible) {\n      IERC1155(token).safeTransferFrom(msg.sender, address(this), tokenId, amount, \"\");\n      stocks[nextId] = amount;\n    } else {\n      IERC721(token).transferFrom(msg.sender, address(this), tokenId);\n    }\n\n    if (feeRate != 0) {\n      price += (price * feeRate) / 10_000;\n    }\n\n    listings[nextId] = Listing(token, tokenId, price, msg.sender, fungible, false);\n\n    emit Listed(nextId, token, tokenId, msg.sender, amount, price, fungible);\n    if (price > 0) {\n      emit Live(nextId, price);\n    }\n    return nextId;\n  }\n\n  function setPrice(uint256 listingId, uint256 price) public {\n    require(listings[listingId].owner == msg.sender, \"only owner can set the listing as live\");\n    require(!listings[listingId].inactive, \"cannnot reactivate revoked/sold listing\");\n\n    if (feeRate != 0) {\n      price += (price * feeRate) / 10_000;\n    }\n\n    listings[listingId].price = price;\n    if (price > 0) {\n      emit Live(listingId, price);\n    }\n  }\n\n  function isLive(uint256 listingId) public view returns (bool) {\n    return listings[listingId].price != 0;\n  }\n\n  function revoke(uint256 listingId) public {\n    require(listings[listingId].owner == msg.sender, \"only listing owner can revoke the listing\");\n    require(!listings[listingId].inactive, \"cannnot revoke revoked/sold listing\");\n\n    Listing storage listing = listings[listingId];\n\n    if (listing.fungible) {\n      require(stocks[listingId] > 0, \"listing has no tokens\");\n      IERC1155 op = IERC1155(listings[listingId].token);\n      op.safeTransferFrom(address(this), msg.sender, listing.tokenId, stocks[listingId], \"\");\n      stocks[listingId] = 0;\n    } else {\n\n      IERC721 op = IERC721(listing.token);\n      op.transferFrom(address(this), msg.sender, listing.tokenId);\n      listings[listingId].inactive = true;\n    }\n\n    emit Revoke(listingId);\n  }\n\n  function _purchase1155(uint256 id, uint256 amount) private returns (uint256 price) {\n    Listing memory listing = listings[id];\n    require(stocks[id] != 0, \"listing not in stock\");\n    require(stocks[id] >= amount, \"not enough in stock\");\n    price = listing.price * amount;\n    stocks[id] = stocks[id] - amount;\n\n    IERC1155 op = IERC1155(listing.token);\n    op.safeTransferFrom(address(this), msg.sender, listing.tokenId, amount, \"\");\n  }\n\n  function _purchase721(uint256 id) private returns (uint256 price) {\n    Listing storage listing = listings[id];\n\n    IERC721 op = IERC721(listing.token);\n    op.safeTransferFrom(address(this), msg.sender, listing.tokenId);\n    listing.inactive = true;\n    return listing.price;\n  }\n\n  function purchase(uint256 listingId, uint256 amount) public {\n    require(amount > 0, \"amount is 0\");\n    require(isLive(listingId), \"listing is not live\");\n    require(!listings[listingId].inactive, \"cannnot purchase revoked/sold listing\");\n\n    Listing memory listing = listings[listingId];\n\n    uint256 price = 0;\n\n    if (listing.fungible) {\n      price = _purchase1155(listingId, amount);\n    } else {\n      price = _purchase721(listingId);\n    }\n\n    if (feeRate != 0) {\n      uint256 fee = (price * feeRate) / 10_000;\n      price = SafeMath.sub(price, fee);\n      // Send the fee to the contract owner\n      operatingToken.transferFrom(msg.sender, owner(), fee);\n    }\n    operatingToken.transferFrom(msg.sender, listing.owner, price);\n\n    emit Sold(listingId, msg.sender, amount);\n  }\n\n  function purchaseBulk(uint256[] calldata listingIds, uint256[] calldata amounts) public {\n    require(listingIds.length == amounts.length, \"array count mismatch\");\n    for (uint256 i = 0; i < listingIds.length; i++) {\n      purchase(listingIds[i], amounts[i]);\n    }\n  }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./extensions/IERC721Metadata.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Strings.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overriden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, _data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits a {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/ERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/ERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC1155.sol\";\nimport \"./IERC1155Receiver.sol\";\nimport \"./extensions/IERC1155MetadataURI.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of the basic standard multi-token.\n * See https://eips.ethereum.org/EIPS/eip-1155\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\n *\n * _Available since v3.1._\n */\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\n    using Address for address;\n\n    // Mapping from token ID to account balances\n    mapping(uint256 => mapping(address => uint256)) private _balances;\n\n    // Mapping from account to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\n    string private _uri;\n\n    /**\n     * @dev See {_setURI}.\n     */\n    constructor(string memory uri_) {\n        _setURI(uri_);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC1155).interfaceId ||\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC1155MetadataURI-uri}.\n     *\n     * This implementation returns the same URI for *all* token types. It relies\n     * on the token type ID substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * Clients calling this function must replace the `\\{id\\}` substring with the\n     * actual token type ID.\n     */\n    function uri(uint256) public view virtual override returns (string memory) {\n        return _uri;\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: balance query for the zero address\");\n        return _balances[id][account];\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOfBatch}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\n        public\n        view\n        virtual\n        override\n        returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }\n\n    /**\n     * @dev See {IERC1155-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC1155-isApprovedForAll}.\n     */\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n    /**\n     * @dev See {IERC1155-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }\n\n    /**\n     * @dev See {IERC1155-safeBatchTransferFrom}.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n        _balances[id][to] += amount;\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Sets a new URI for all token types, by relying on the token type ID\n     * substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\n     * clients with the token type ID.\n     *\n     * For example, the `https://token-cdn-domain/\\{id\\}.json` URI would be\n     * interpreted by clients as\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\n     * for token type ID 0x4cce0.\n     *\n     * See {uri}.\n     *\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\n     * this function emits no events.\n     */\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n\n    /**\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), to, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        _balances[id][to] += amount;\n        emit TransferSingle(operator, address(0), to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] += amounts[i];\n        }\n\n        emit TransferBatch(operator, address(0), to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens of token type `id` from `from`\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `from` must have at least `amount` tokens of token type `id`.\n     */\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, address(0), _asSingletonArray(id), _asSingletonArray(amount), \"\");\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n\n        emit TransferSingle(operator, from, address(0), id, amount);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     */\n    function _burnBatch(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n        }\n\n        emit TransferBatch(operator, from, address(0), ids, amounts);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits a {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC1155: setting approval status for self\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `id` and `amount` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\n                bytes4 response\n            ) {\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\n        uint256[] memory array = new uint256[](1);\n        array[0] = element;\n\n        return array;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/IERC1155MetadataURI.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC1155.sol\";\n\n/**\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155MetadataURI is IERC1155 {\n    /**\n     * @dev Returns the URI for token type `id`.\n     *\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n     * clients with the actual token type ID.\n     */\n    function uri(uint256 id) external view returns (string memory);\n}\n"
    },
    "contracts/gwit/FarmPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\ninterface IMigratorChef {\n  // Perform LP token migration from legacy UniswapV2 to GwitSwap.\n  // Take the current LP token address and return the new LP token address.\n  // Migrator should have full access to the caller's LP token.\n  // Return the new LP token address.\n  //\n  // XXX Migrator must have allowance access to UniswapV2 LP tokens.\n  // GwitSwap must mint EXACTLY the same amount of GwitSwap LP tokens or\n  // else something bad will happen. Traditional UniswapV2 does not\n  // do that so be careful!\n  function migrate(IERC20 token) external returns (IERC20);\n}\n\n// MasterChef is the master of Gwit. He can make Gwit and he is a fair guy.\n//\n// Note that it's ownable and the owner wields tremendous power. The ownership\n// will be transferred to a governance smart contract once GWIT is sufficiently\n// distributed and the community can show to govern itself.\n//\n// Have fun reading it. Hopefully it's bug-free. God bless.\ncontract MasterChef is Ownable {\n  using SafeMath for uint256;\n  using SafeERC20 for IERC20;\n\n  // Info of each user.\n  struct UserInfo {\n    uint256 amount; // How many LP tokens the user has provided.\n    uint256 rewardDebt; // Reward debt. See explanation below.\n    //\n    // We do some fancy math here. Basically, any point in time, the amount of GWITs\n    // entitled to a user but is pending to be distributed is:\n    //\n    //   pending reward = (user.amount * pool.accGwitPerShare) - user.rewardDebt\n    //\n    // Whenever a user deposits or withdraws LP tokens to a pool. Here's what happens:\n    //   1. The pool's `accGwitPerShare` (and `lastRewardBlock`) gets updated.\n    //   2. User receives the pending reward sent to his/her address.\n    //   3. User's `amount` gets updated.\n    //   4. User's `rewardDebt` gets updated.\n  }\n\n  // Info of each pool.\n  struct PoolInfo {\n    IERC20 lpToken; // Address of LP token contract.\n    uint256 allocPoint; // How many allocation points assigned to this pool. GWITs to distribute per block.\n    uint256 lastRewardBlock; // Last block number that GWITs distribution occurs.\n    uint256 accGwitPerShare; // Accumulated GWITs per share, times 1e12. See below.\n  }\n\n  // The GWIT TOKEN!\n  IERC20 public gwit;\n  // Dev address.\n  address public devaddr;\n  // Block number when bonus GWIT period ends.\n  uint256 public bonusEndBlock;\n  // GWIT tokens created per block.\n  uint256 public gwitPerBlock;\n  // Bonus muliplier for early gwit makers.\n  uint256 public constant BONUS_MULTIPLIER = 10;\n  // The migrator contract. It has a lot of power. Can only be set through governance (owner).\n  IMigratorChef public migrator;\n\n  // Info of each pool.\n  PoolInfo[] public poolInfo;\n  // Info of each user that stakes LP tokens.\n  mapping(uint256 => mapping(address => UserInfo)) public userInfo;\n  // Total allocation poitns. Must be the sum of all allocation points in all pools.\n  uint256 public totalAllocPoint = 0;\n  // The block number when GWIT mining starts.\n  uint256 public startBlock;\n\n  event Deposit(address indexed user, uint256 indexed pid, uint256 amount);\n  event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\n  event EmergencyWithdraw(address indexed user, uint256 indexed pid, uint256 amount);\n\n  constructor(\n    IERC20 _gwit,\n    address _devaddr,\n    uint256 _gwitPerBlock,\n    uint256 _startBlock,\n    uint256 _bonusEndBlock\n  ) {\n    gwit = _gwit;\n    devaddr = _devaddr;\n    gwitPerBlock = _gwitPerBlock;\n    bonusEndBlock = _bonusEndBlock;\n    startBlock = _startBlock;\n  }\n\n  function poolLength() external view returns (uint256) {\n    return poolInfo.length;\n  }\n\n  // Add a new lp to the pool. Can only be called by the owner.\n  // XXX DO NOT add the same LP token more than once. Rewards will be messed up if you do.\n  function add(\n    uint256 _allocPoint,\n    IERC20 _lpToken,\n    bool _withUpdate\n  ) public onlyOwner {\n    if (_withUpdate) {\n      massUpdatePools();\n    }\n    uint256 lastRewardBlock = block.number > startBlock ? block.number : startBlock;\n    totalAllocPoint = totalAllocPoint.add(_allocPoint);\n    poolInfo.push(\n      PoolInfo({\n        lpToken: _lpToken,\n        allocPoint: _allocPoint,\n        lastRewardBlock: lastRewardBlock,\n        accGwitPerShare: 0\n      })\n    );\n  }\n\n  // Update the given pool's GWIT allocation point. Can only be called by the owner.\n  function set(\n    uint256 _pid,\n    uint256 _allocPoint,\n    bool _withUpdate\n  ) public onlyOwner {\n    if (_withUpdate) {\n      massUpdatePools();\n    }\n    totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(_allocPoint);\n    poolInfo[_pid].allocPoint = _allocPoint;\n  }\n\n  // Set the migrator contract. Can only be called by the owner.\n  function setMigrator(IMigratorChef _migrator) public onlyOwner {\n    migrator = _migrator;\n  }\n\n  // Migrate lp token to another lp contract. Can be called by anyone. We trust that migrator contract is good.\n  function migrate(uint256 _pid) public {\n    require(address(migrator) != address(0), \"migrate: no migrator\");\n    PoolInfo storage pool = poolInfo[_pid];\n    IERC20 lpToken = pool.lpToken;\n    uint256 bal = lpToken.balanceOf(address(this));\n    lpToken.safeApprove(address(migrator), bal);\n    IERC20 newLpToken = migrator.migrate(lpToken);\n    require(bal == newLpToken.balanceOf(address(this)), \"migrate: bad\");\n    pool.lpToken = newLpToken;\n  }\n\n  // Return reward multiplier over the given _from to _to block.\n  function getMultiplier(uint256 _from, uint256 _to) public view returns (uint256) {\n    if (_to <= bonusEndBlock) {\n      return _to.sub(_from).mul(BONUS_MULTIPLIER);\n    } else if (_from >= bonusEndBlock) {\n      return _to.sub(_from);\n    } else {\n      return bonusEndBlock.sub(_from).mul(BONUS_MULTIPLIER).add(_to.sub(bonusEndBlock));\n    }\n  }\n\n  // View function to see pending GWITs on frontend.\n  function pendingGwit(uint256 _pid, address _user) external view returns (uint256) {\n    PoolInfo storage pool = poolInfo[_pid];\n    UserInfo storage user = userInfo[_pid][_user];\n    uint256 accGwitPerShare = pool.accGwitPerShare;\n    uint256 lpSupply = pool.lpToken.balanceOf(address(this));\n    if (block.number > pool.lastRewardBlock && lpSupply != 0) {\n      uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number);\n      uint256 gwitReward = multiplier.mul(gwitPerBlock).mul(pool.allocPoint).div(totalAllocPoint);\n      accGwitPerShare = accGwitPerShare.add(gwitReward.mul(1e12).div(lpSupply));\n    }\n    return user.amount.mul(accGwitPerShare).div(1e12).sub(user.rewardDebt);\n  }\n\n  // Update reward vairables for all pools. Be careful of gas spending!\n  function massUpdatePools() public {\n    uint256 length = poolInfo.length;\n    for (uint256 pid = 0; pid < length; ++pid) {\n      updatePool(pid);\n    }\n  }\n\n  // Update reward variables of the given pool to be up-to-date.\n  function updatePool(uint256 _pid) public {\n    PoolInfo storage pool = poolInfo[_pid];\n    if (block.number <= pool.lastRewardBlock) {\n      return;\n    }\n    uint256 lpSupply = pool.lpToken.balanceOf(address(this));\n    if (lpSupply == 0) {\n      pool.lastRewardBlock = block.number;\n      return;\n    }\n    uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number);\n    uint256 gwitReward = multiplier.mul(gwitPerBlock).mul(pool.allocPoint).div(totalAllocPoint);\n    gwit.transfer(devaddr, gwitReward.div(10));\n    // gwit.mint(address(this), gwitReward);\n    pool.accGwitPerShare = pool.accGwitPerShare.add(gwitReward.mul(1e12).div(lpSupply));\n    pool.lastRewardBlock = block.number;\n  }\n\n  // Deposit LP tokens to MasterChef for GWIT allocation.\n  function deposit(uint256 _pid, uint256 _amount) public {\n    PoolInfo storage pool = poolInfo[_pid];\n    UserInfo storage user = userInfo[_pid][msg.sender];\n    updatePool(_pid);\n    if (user.amount > 0) {\n      uint256 pending = user.amount.mul(pool.accGwitPerShare).div(1e12).sub(user.rewardDebt);\n      safeGwitTransfer(msg.sender, pending);\n    }\n    pool.lpToken.safeTransferFrom(address(msg.sender), address(this), _amount);\n    user.amount = user.amount.add(_amount);\n    user.rewardDebt = user.amount.mul(pool.accGwitPerShare).div(1e12);\n    emit Deposit(msg.sender, _pid, _amount);\n  }\n\n  // Withdraw LP tokens from MasterChef.\n  function withdraw(uint256 _pid, uint256 _amount) public {\n    PoolInfo storage pool = poolInfo[_pid];\n    UserInfo storage user = userInfo[_pid][msg.sender];\n    require(user.amount >= _amount, \"withdraw: not good\");\n    updatePool(_pid);\n    uint256 pending = user.amount.mul(pool.accGwitPerShare).div(1e12).sub(user.rewardDebt);\n    safeGwitTransfer(msg.sender, pending);\n    user.amount = user.amount.sub(_amount);\n    user.rewardDebt = user.amount.mul(pool.accGwitPerShare).div(1e12);\n    pool.lpToken.safeTransfer(address(msg.sender), _amount);\n    emit Withdraw(msg.sender, _pid, _amount);\n  }\n\n  // Withdraw without caring about rewards. EMERGENCY ONLY.\n  function emergencyWithdraw(uint256 _pid) public {\n    PoolInfo storage pool = poolInfo[_pid];\n    UserInfo storage user = userInfo[_pid][msg.sender];\n    pool.lpToken.safeTransfer(address(msg.sender), user.amount);\n    emit EmergencyWithdraw(msg.sender, _pid, user.amount);\n    user.amount = 0;\n    user.rewardDebt = 0;\n  }\n\n  // Safe gwit transfer function, just in case if rounding error causes pool to not have enough GWITs.\n  function safeGwitTransfer(address _to, uint256 _amount) internal {\n    uint256 gwitBal = gwit.balanceOf(address(this));\n    if (_amount > gwitBal) {\n      gwit.transfer(_to, gwitBal);\n    } else {\n      gwit.transfer(_to, _amount);\n    }\n  }\n\n  // Update dev address by the previous dev.\n  function dev(address _devaddr) public {\n    require(msg.sender == devaddr, \"dev: wut?\");\n    devaddr = _devaddr;\n  }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "contracts/store/Claimable.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n/**\n  Claimable\n */\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nabstract contract Claimable is Ownable {\n  mapping(address => bool) public signers;\n  mapping(uint256 => bool) public burned;\n\n  struct Claim {\n    uint256 nonce;\n    address target;\n    uint256 amount;\n    Sig signature;\n  }\n\n  struct Sig {\n    bytes32 r;\n    bytes32 s;\n    uint8 v;\n  }\n\n  event UpdateSigner(address signer, bool state);\n  event Claimed(uint256 indexed nonce, address indexed target, uint256 amount);\n\n  function setSigner(address _signer, bool _state) public onlyOwner {\n    signers[_signer] = _state;\n    emit UpdateSigner(_signer, _state);\n  }\n\n  function authorize(\n    Sig calldata sig,\n    uint256 nonce,\n    bytes32 messageHash\n  ) internal view returns (bool) {\n    require(!burned[nonce], \"Claimable:BURNED\");\n    bytes32 ethSignedMessageHash = keccak256(\n      abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", messageHash)\n    );\n    address signer = ecrecover(ethSignedMessageHash, sig.v, sig.r, sig.s);\n    return signers[signer];\n  }\n\n  function validateClaim(Claim calldata claimData) public view returns (bool) {\n    bytes32 messageHash = keccak256(\n      abi.encodePacked(claimData.nonce, claimData.target, claimData.amount)\n    );\n    return authorize(claimData.signature, claimData.nonce, messageHash);\n  }\n\n  function _burn_nonce(uint256 nonce) internal {\n    burned[nonce] = true;\n  }\n}\n"
    },
    "contracts/store/Store.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\n/**\n  Marketplace spec: https://www.notion.so/RoosterWars-Marketplace-6350187ee37f4e239aa8441b7e634e00\n */\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"./Claimable.sol\";\n\ncontract Store is Ownable, Claimable {\n  IERC20 public operatingToken;\n  uint256 public feeRate;\n  address immutable vault;\n\n  enum TokenType {\n    ERC1155,\n    ERC1155EXT,\n    ERC721,\n    ERC721EXT\n  }\n\n  struct Listing {\n    address token;\n    uint256 tokenId;\n    address owner;\n    uint256 price;\n    TokenType tokentype;\n    uint256 maxval;\n  }\n\n  struct Permit {\n    address owner;\n    address spender;\n    uint256 value;\n    uint256 deadline;\n    uint8 v;\n    bytes32 r;\n    bytes32 s;\n  }\n\n  uint256 public nextId;\n  // { listingId: Listing}\n  mapping(uint256 => Listing) public listings;\n  mapping(uint256 => bool) public inactive;\n  // { listingId: inStock }\n  mapping(uint256 => uint256) public stocks;\n  // { account: allowed }\n  mapping(address => bool) public allowedLister;\n  // { account: block.number}\n  mapping(address => uint256) public last_purchase;\n\n  //==============================\n  // for affiliate marketing\n  address private affiliateAddress;\n\n  event Listed(\n    uint256 listingId,\n    address token,\n    uint256 tokenId,\n    address owner,\n    uint256 amount,\n    uint256 price,\n    TokenType tokentype\n  );\n  event Sold(uint256 listingId, address indexed buyer, uint256 amount);\n  event Revoke(uint256 listingId);\n\n  constructor(IERC20 _operatingToken, address _vault) {\n    operatingToken = _operatingToken;\n    vault = _vault;\n  }\n\n  /*\n        setAllowedLister gives an account access to call the makeListing method.\n    */\n  function setAllowedLister(address account, bool allowed) public onlyOwner {\n    allowedLister[account] = allowed;\n  }\n\n  /*\n        setFeeRate sets the fee in down to a hundredth of a percent.\n        1    =    0.01%\n        100  =   10.00%\n        1000 =  100.00%\n    */\n  function setFeeRate(uint256 _feeRate) public onlyOwner {\n    feeRate = _feeRate;\n  }\n\n  /*\n        restock refills the amount of tokens the contract is allowed to muint\n    */\n  function restock(uint256 listingId, uint256 amount) public {\n    require(listings[listingId].owner == msg.sender, \"not listing owner\");\n    stocks[listingId] += amount;\n  }\n\n  /*\n        makeListing creates a listing based on the tokenType\n            Token types with an EX suffix is expected to have a mint() function with an additional\n        argument where the shop passes a random number based on the 'maxval' argument.\n            The random value is [0, maxval). And is generated through the signer's signature.\n    */\n  function makeListing(\n    TokenType tokenType,\n    address token,\n    uint256 tokenId,\n    uint256 amount,\n    uint256 price,\n    uint256 maxval\n  ) public returns (uint256) {\n    require(allowedLister[msg.sender], \"STORE:NOT_AUTHORIZED\");\n    unchecked {\n      nextId = nextId + 1;\n    }\n\n    // Verify that it conforms to the Mintable interface by making sure the mint method can be called.\n    bytes memory payload = _generatePayload(msg.sender, tokenType, tokenId, 1, 0, \"\", 0);\n    (bool ok, ) = token.call(payload);\n\n    require(ok, \"Store:TOKEN_VALIDATE_FAILED\");\n\n    if (feeRate != 0) {\n      price += (price * feeRate) / 10_000;\n    }\n\n    listings[nextId] = Listing(token, tokenId, msg.sender, price, tokenType, maxval);\n    stocks[nextId] = amount;\n\n    emit Listed(nextId, token, tokenId, msg.sender, amount, price, tokenType);\n    return nextId;\n  }\n\n  /*\n        reprice changes the listing's price.\n    */\n  function reprice(uint256 listingId, uint256 price) public {\n    require(listings[listingId].owner == msg.sender, \"only owner can reprice the listing\");\n\n    if (feeRate != 0) {\n      price += (price * feeRate) / 10_000;\n    }\n\n    Listing memory l = listings[listingId];\n    l.price = price;\n    listings[listingId] = l;\n  }\n\n  /*\n        setActive changes the listing's state.\n    */\n  function setActive(uint256 listingId, bool active) public {\n    require(listings[listingId].owner == msg.sender, \"only listing owner can revoke the listing\");\n\n    inactive[listingId] = active;\n    emit Revoke(listingId);\n  }\n\n  function _generatePayload(\n    address recv,\n    TokenType tokentype,\n    uint256 id,\n    uint256 amount,\n    uint256 i,\n    bytes32 r,\n    uint256 max\n  ) internal view returns (bytes memory payload) {\n    if (tokentype == TokenType.ERC1155) {\n\n      payload = abi.encodeWithSignature(\"mint(address,uint256,uint256)\", recv, id, amount);\n    } else if (tokentype == TokenType.ERC1155EXT) {\n      uint256 unique = uint256(keccak256(abi.encodePacked(r, i)));\n\n      if (max > 0) {\n        unique = unique % max;\n      }\n      payload = abi.encodeWithSignature(\n        \"mint(address,uint256,uint256,uint256)\",\n        recv,\n        id,\n        amount,\n        unique\n      );\n    } else if (tokentype == TokenType.ERC721) {\n      payload = abi.encodeWithSignature(\"mint(address)\", recv);\n    } else if (tokentype == TokenType.ERC721EXT) {\n      uint256 unique = uint256(keccak256(abi.encodePacked(r, i)));\n\n      if (max > 0) {\n        unique = unique % max;\n      }\n      payload = abi.encodeWithSignature(\"mint(address,uint256)\", recv, unique);\n    }\n  }\n\n  function purchase(\n    address to,\n    uint256[] calldata listingIds,\n    uint256[] calldata amounts,\n    Claim calldata claimData\n  ) public {\n    require(claimData.target == msg.sender, \"Store:NOT_AUTHORIZED\");\n    require(validateClaim(claimData), \"Store:INVALID_CLAIM\");\n    require(claimData.amount == last_purchase[msg.sender], \"Store:OLD_CLAIM\");\n    _burn_nonce(claimData.nonce);\n    last_purchase[msg.sender] = block.number;\n\n    require(listingIds.length == amounts.length, \"Store:PARAMETER_MISMATCH\");\n\n    for (uint256 i = 0; i < listingIds.length; i++) {\n      uint256 amount = amounts[i];\n      uint256 listingId = listingIds[i];\n\n      require(!inactive[listingId], \"Store:INACTIVE_LISTING\");\n      require(stocks[listingId] >= amount, \"Store:INSUFFICIENT_STOCK\");\n\n      Listing memory listing = listings[listingId];\n\n      stocks[listingId] -= amount;\n      uint256 price = listing.price * amount;\n      if (feeRate != 0) {\n        uint256 fee = (price * feeRate) / 10_000;\n        price -= fee;\n        // Send the fee to the contract owner\n        operatingToken.transferFrom(msg.sender, vault, fee);\n      }\n      operatingToken.transferFrom(msg.sender, listing.owner, price);\n\n      bytes memory payload = _generatePayload(\n        to,\n        listing.tokentype,\n        listing.tokenId,\n        amount,\n        i,\n        claimData.signature.r,\n        listing.maxval\n      );\n\n      (bool ok, ) = listing.token.call(payload);\n      require(ok);\n\n      emit Sold(listingId, claimData.target, amount);\n    }\n  }\n\n  function purchasePermit(\n    address to,\n    uint256[] calldata listingIds,\n    uint256[] calldata amounts,\n    Claim calldata claimData,\n    Permit calldata _permit\n  ) public {\n    IERC20Permit permit = IERC20Permit(address(operatingToken));\n    permit.permit(\n      _permit.owner,\n      _permit.spender,\n      _permit.value,\n      _permit.deadline,\n      _permit.v,\n      _permit.r,\n      _permit.s\n    );\n    purchase(to, listingIds, amounts, claimData);\n  }\n\n  // for affiliate sale\n  function setAffiliateAddress(address _address) public onlyOwner {\n    affiliateAddress = _address;\n  }\n\n  modifier onlyAffiliate() {\n    require(affiliateAddress == msg.sender, \"Store:NOT_AFFILIATE\");\n    _;\n  }\n\n  function buyItemWithAffiliate(\n    address from,\n    address to,\n    uint256 listingId,\n    uint256 amount\n  ) public onlyAffiliate {\n    require(!inactive[listingId], \"Store:INACTIVE_LISTING\");\n    require(stocks[listingId] >= amount, \"Store:INSUFFICIENT_STOCK\");\n\n    Listing memory listing = listings[listingId];\n\n    stocks[listingId] -= amount;\n    uint256 price = listing.price * amount;\n    if (feeRate != 0) {\n      uint256 fee = (price * feeRate) / 10_000;\n      price -= fee;\n      // Send the fee to the contract owner\n      operatingToken.transferFrom(from, vault, fee);\n    }\n    operatingToken.transferFrom(from, listing.owner, price);\n\n    bytes memory payload = _generatePayload(\n      to,\n      listing.tokentype,\n      listing.tokenId,\n      amount,\n      0,\n      bytes32(0),\n      listing.maxval\n    );\n\n    (bool ok, ) = listing.token.call(payload);\n    require(ok);\n\n    emit Sold(listingId, to, amount);\n  }\n}\n"
    },
    "contracts/scholarship/Scholarship.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\ncontract Scholarship is Ownable {\n  IERC721 public immutable nft_contract;\n  bool public disabled;\n\n  mapping(uint256 => address) public nft_scholar;\n  mapping(uint256 => address) public nft_owner;\n  mapping(address => uint256) public lended_nfts;\n\n  event Lend(uint256 nft_id, address scholar);\n  event Transfer(uint256 nft_id, address scholar);\n  event Revoke(uint256 nft_id);\n  event Disable();\n  event Enable();\n\n  constructor(address _nft_contract_address) {\n    nft_contract = IERC721(_nft_contract_address);\n  }\n\n  function onERC721Received(\n    address,\n    address,\n    uint256,\n    bytes calldata\n  ) public pure returns (bytes4) {\n    return this.onERC721Received.selector;\n  }\n\n  modifier notDisabled() {\n    require(!disabled, \"Scholarship:CONTRACT_DISABLED\");\n    _;\n  }\n\n  modifier shouldBeOwner(uint256 nft_id) {\n    require(nft_owner[nft_id] == msg.sender, \"Scholarship:NOT_OWNER\");\n    _;\n  }\n\n  modifier lended(uint256 nft_id) {\n    require(nft_owner[nft_id] != address(0), \"Scholarship:NOT_LENDED\");\n    _;\n  }\n\n  function disable() public onlyOwner {\n    disabled = true;\n\n    emit Disable();\n  }\n\n  function enable() public onlyOwner {\n    disabled = false;\n\n    emit Enable();\n  }\n\n  function info(uint256 nft_id)\n    public\n    view\n    lended(nft_id)\n    returns (address owner, address scholar)\n  {\n    owner = nft_owner[nft_id];\n    scholar = nft_scholar[nft_id];\n  }\n\n  function getOwner(uint256 nft_id) public view lended(nft_id) returns (address owner) {\n    owner = nft_owner[nft_id];\n  }\n\n  function getScholar(uint256 nft_id) public view lended(nft_id) returns (address scholar) {\n    scholar = nft_scholar[nft_id];\n  }\n\n  function lendNFT(uint256 nft_id, address scholar) public notDisabled {\n    nft_scholar[nft_id] = scholar;\n    nft_owner[nft_id] = msg.sender;\n    unchecked {\n      lended_nfts[msg.sender] += 1;\n    }\n\n    nft_contract.safeTransferFrom(msg.sender, address(this), nft_id);\n    emit Lend(nft_id, scholar);\n  }\n\n  function transferScholar(uint256 nft_id, address scholar)\n    public\n    notDisabled\n    shouldBeOwner(nft_id)\n  {\n    nft_scholar[nft_id] = scholar;\n\n    emit Transfer(nft_id, scholar);\n  }\n\n  function revoke(uint256 nft_id) public shouldBeOwner(nft_id) {\n    lended_nfts[msg.sender] = lended_nfts[msg.sender] - 1;\n    nft_owner[nft_id] = address(0);\n    nft_scholar[nft_id] = address(0);\n\n    nft_contract.safeTransferFrom(address(this), msg.sender, nft_id);\n\n    emit Revoke(nft_id);\n  }\n\n  function bulkLendNFT(uint256[] calldata nft_ids, address[] calldata scholars) public {\n    require(nft_ids.length == scholars.length, \"Scholarship:PARAM_MISMATCH\");\n\n    for (uint256 i = 0; i < nft_ids.length; i++) {\n      lendNFT(nft_ids[i], scholars[i]);\n    }\n  }\n\n  function bulkTransferScholar(uint256[] calldata nft_ids, address[] calldata scholars) public {\n    require(nft_ids.length == scholars.length, \"Scholarship:PARAM_MISMATCH\");\n\n    for (uint256 i = 0; i < nft_ids.length; i++) {\n      transferScholar(nft_ids[i], scholars[i]);\n    }\n  }\n\n  function bulkRevoke(uint256[] calldata nft_ids) public {\n    for (uint256 i = 0; i < nft_ids.length; i++) {\n      revoke(nft_ids[i]);\n    }\n  }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/ERC721Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721.sol\";\nimport \"../../../utils/Context.sol\";\n\n/**\n * @title ERC721 Burnable Token\n * @dev ERC721 Token that can be irreversibly burned (destroyed).\n */\nabstract contract ERC721Burnable is Context, ERC721 {\n    /**\n     * @dev Burns `tokenId`. See {ERC721-_burn}.\n     *\n     * Requirements:\n     *\n     * - The caller must own `tokenId` or be an approved operator.\n     */\n    function burn(uint256 tokenId) public virtual {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721Burnable: caller is not owner nor approved\");\n        _burn(tokenId);\n    }\n}\n"
    },
    "contracts/betting/IJackPotTicket.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IJackPotTicket is IERC165 {\n  /**\n   * @dev Returns the number of tokens in ``owner``'s account.\n   */\n  function balanceOf(address owner) external view returns (uint256 balance);\n\n  /**\n   * @dev Returns the owner of the `tokenId` token.\n   *\n   * Requirements:\n   *\n   * - `tokenId` must exist.\n   */\n  function ownerOf(uint256 tokenId) external view returns (address owner);\n\n  /**\n   * @dev Returns the token collection name.\n   */\n  function name() external view returns (string memory);\n\n  /**\n   * @dev Returns the token collection symbol.\n   */\n  function symbol() external view returns (string memory);\n\n  /**\n   * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n   */\n  function tokenURI(uint256 tokenId) external view returns (string memory);\n\n  // events\n  event NewRequest(uint256 indexed id);\n}\n"
    },
    "contracts/betting/JackPotTicket.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.9;\n\nimport \"./IJackPotTicket.sol\";\nimport \"../utils/Auth.sol\";\nimport \"../utils/VRF/VRFv2Consumer.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\n\ncontract JackPotTicket is Auth, VRFv2Consumer, IJackPotTicket {\n  // Token name\n  string private _name;\n\n  // Token symbol\n  string private _symbol;\n\n  // Mapping from token ID to owner address\n  mapping(uint256 => address) private _owners;\n\n  // Mapping owner address to token count\n  mapping(address => uint256) private _balances;\n\n  uint256 private _tokenCounter;\n  address private _treasuryAddr;\n  string private _baseTokenURI;\n\n  uint256 public closeTime;\n  uint256 public openTime;\n  uint256 public period;\n  uint256 public withdrawPeriod;\n  uint256 public totalDistributeAmount;\n  bytes32 public clientSeed;\n  address public token;\n  mapping(address => bool) public allowedTokens;\n\n  mapping(uint256 => mapping(address => bool)) private rewarded;\n  mapping(uint256 => uint256) private requestIds;\n  uint256 public currentRound;\n\n  struct Sig {\n    bytes32 r;\n    bytes32 s;\n    uint8 v;\n  }\n\n  constructor(uint64 subscriptionId, address vrfCoordinator)\n    VRFv2Consumer(subscriptionId, vrfCoordinator)\n  {\n    _name = \"RoosterWarsJackpotTicket\";\n    _symbol = \"RWJT\";\n    period = 1 weeks;\n    withdrawPeriod = 3 days;\n    _treasuryAddr = msg.sender;\n    closeTime = block.timestamp;\n    openTime = block.timestamp;\n    currentRound = 0;\n  }\n\n  /**\n   * @dev See {JackPotTicket-balanceOf}.\n   */\n  function balanceOf(address owner) public view virtual returns (uint256) {\n    require(owner != address(0), \"JackPotTicket: balance query for the zero address\");\n    return _balances[owner];\n  }\n\n  /**\n   * @dev See {JackPotTicket-ownerOf}.\n   */\n  function ownerOf(uint256 tokenId) public view virtual returns (address) {\n    address owner = _owners[tokenId];\n    require(owner != address(0), \"JackPotTicket: owner query for nonexistent token\");\n    return owner;\n  }\n\n  /**\n   * @dev See {JackPotTicket-name}.\n   */\n  function name() public view virtual returns (string memory) {\n    return _name;\n  }\n\n  /**\n   * @dev See {JackPotTicket-symbol}.\n   */\n  function symbol() public view virtual returns (string memory) {\n    return _symbol;\n  }\n\n  /**\n   * @dev Returns true if this contract implements the interface defined by\n   * `interfaceId`. See the corresponding\n   * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n   * to learn more about how these ids are created.\n   *\n   * This function call must use less than 30 000 gas.\n   */\n  function supportsInterface(bytes4 interfaceId)\n    public\n    view\n    virtual\n    override(IERC165)\n    returns (bool)\n  {\n    return interfaceId == type(IJackPotTicket).interfaceId;\n  }\n\n  /**\n   * @dev Mints `tokenId` and transfers it to `to`.\n   *\n   * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n   *\n   * Requirements:\n   *\n   * - `tokenId` must not exist.\n   * - `to` cannot be the zero address.\n   *\n   * Emits a {Transfer} event.\n   */\n  function _mint(address to, uint256 tokenId) internal virtual {\n    require(to != address(0), \"JackPotTicket: mint to the zero address\");\n    require(!_exists(tokenId), \"JackPotTicket: token already minted\");\n\n    _balances[to] += 1;\n    _owners[tokenId] = to;\n  }\n\n  /**\n   * @dev Returns whether `tokenId` exists.\n   *\n   * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n   *\n   * Tokens start existing when they are minted (`_mint`),\n   * and stop existing when they are burned (`_burn`).\n   */\n  function _exists(uint256 tokenId) internal view virtual returns (bool) {\n    return _owners[tokenId] != address(0);\n  }\n\n  // function:  return true if sender has ticket\n  modifier hasTicket() {\n    require(balanceOf(msg.sender) > 0, \"JackPotTicket:NO_TICKET\");\n    _;\n  }\n\n  // function:  mint amount ticket to 'to' address\n  // @param:    amount: number of ticket\n  // @param:    to: address of owner\n  function mintTo(uint256 amount, address to) public {\n    require(hasRole(\"MINTER\", msg.sender), \"JackPotTicket:CANT_MINT\");\n\n    uint256 tokenId = _tokenCounter;\n    for (uint256 i = 0; i < amount; i++) {\n      _mint(to, tokenId);\n      tokenId++;\n    }\n\n    _tokenCounter = tokenId;\n  }\n\n  // function:  validate create function params\n  // @return    true -> valid, false -> invalid\n  function _validateCreateParam(address tokenAddr, Sig calldata sig)\n    private\n    view\n    onlyRole(\"MAINTAINER\")\n    returns (bool)\n  {\n    bytes32 messageHash = keccak256(abi.encodePacked(msg.sender, tokenAddr));\n    bytes32 ethSignedMessageHash = keccak256(\n      abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", messageHash)\n    );\n\n    return hasRole(\"SIGNER\", ecrecover(ethSignedMessageHash, sig.v, sig.r, sig.s));\n  }\n\n  // function:  create new round\n  // @param:    toeknAddr: address of token to be rewarded\n  // @param:    sig: signer signature struct for creating\n  function createRound(address tokenAddr, Sig calldata sig) public {\n    require(allowedTokens[tokenAddr], \"JackPotTicket:INVALID_TOKEN\");\n    require(block.timestamp >= openTime, \"JackPotTicket:NOT_REWARDED\");\n    require(_validateCreateParam(tokenAddr, sig), \"JackPotTicket:NOT_SIGNER\");\n\n    uint256 totalAmount = IERC20(tokenAddr).balanceOf(address(this));\n    require(totalAmount > 0, \"JackPotTicket:INSUFFICIENT_BALANCE\");\n\n    closeTime = block.timestamp + period;\n    totalDistributeAmount = totalAmount;\n    token = tokenAddr;\n    clientSeed = bytes32(0);\n    IERC20(token).transfer(_treasuryAddr, totalAmount / 20);\n  }\n\n  // function:  validate finish function params\n  // @return    true -> valid, false -> invalid\n  function _validateFinishParam(Sig calldata sig) private view returns (bool) {\n    bytes32 messageHash = keccak256(abi.encodePacked(msg.sender));\n    bytes32 ethSignedMessageHash = keccak256(\n      abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", messageHash)\n    );\n\n    return hasRole(\"SIGNER\", ecrecover(ethSignedMessageHash, sig.v, sig.r, sig.s));\n  }\n\n  // function:  finish round\n  // @param:    sig: signer signature struct to finish\n  function finishRound(Sig calldata sig) public onlyRole(\"MAINTAINER\") returns (uint256) {\n    require(_validateFinishParam(sig), \"JackPotTicket:NOT_SIGNER\");\n    require(block.timestamp > closeTime, \"JackPotTicket:NOT_FINISHED\");\n    openTime = block.timestamp + withdrawPeriod;\n    currentRound++;\n    requestIds[currentRound - 1] = requestRandomWords();\n\n    emit NewRequest(requestIds[currentRound - 1]);\n\n    return requestIds[currentRound - 1];\n  }\n\n  // function:  return reward amount\n  // @return:   amount of reward\n  function getResult() public view hasTicket returns (uint256) {\n    require(block.timestamp > closeTime, \"JackPotTicket:NOT_FINISHED\");\n    require(block.timestamp < openTime, \"JackPotTicket:TIME_OVER\");\n\n    address[] memory addressList = getWinnerAddressList();\n    uint256 reward = 0;\n\n    if (msg.sender == addressList[0]) {\n      reward += (totalDistributeAmount * 80) / 100; // 80% to winner\n    }\n\n    for (uint256 i = 1; i < 11; i++) {\n      if (msg.sender == addressList[i]) {\n        reward += (totalDistributeAmount * 15) / 1000; // 1.5% to winners\n      }\n    }\n\n    return reward;\n  }\n\n  // function:  return reward\n  function withdrawReward() public {\n    uint256 reward = getResult();\n    require(reward > 0, \"JackPotTicket:NO_REWARD\");\n    require(rewarded[currentRound - 1][msg.sender] == false, \"JackPotTicket:REWARDED\");\n\n    rewarded[currentRound - 1][msg.sender] = true;\n\n    IERC20(token).transfer(msg.sender, reward);\n  }\n\n  // function:  return close time\n  // @return:    close time of reward\n  function getCloseTime() public view returns (uint256) {\n    return closeTime;\n  }\n\n  // function:  return address list of winners\n  // @return:   list of address\n  function getWinnerAddressList() public view returns (address[] memory) {\n    require(s_randomWords[requestIds[currentRound - 1]].length == 2, \"JackPotTicket:NOT_FINISHED\");\n    address[] memory addressList = new address[](11);\n    uint256 total = _tokenCounter;\n    bytes32 serverSeed = keccak256(\n      abi.encodePacked(\n        s_randomWords[requestIds[currentRound - 1]][0],\n        s_randomWords[requestIds[currentRound - 1]][1]\n      )\n    );\n\n    bytes32 hashed = keccak256(abi.encodePacked(serverSeed, clientSeed, total));\n\n    for (uint256 i = 0; i < 11; i++) {\n      hashed = keccak256(abi.encodePacked(hashed, serverSeed, clientSeed, total));\n      uint256 winnerIndex = uint256(hashed) % total;\n      addressList[i] = ownerOf(winnerIndex % total);\n    }\n\n    return addressList;\n  }\n\n  // function:    return address list of jackpot ticket owners\n  // @param:      array of address\n  function getAddressList() public view returns (address[] memory) {\n    uint256 total = _tokenCounter;\n    address[] memory addressList = new address[](total);\n\n    for (uint256 i = 0; i < total; i++) {\n      addressList[i] = ownerOf(i);\n    }\n\n    return addressList;\n  }\n\n  // function:    return total reward amount and token symbol\n  function getTotalReward() public view returns (string memory tokenName, uint256 amount) {\n    tokenName = IERC20Metadata(token).symbol();\n    amount = totalDistributeAmount;\n  }\n\n  // setData\n\n  // function:    set NTT metadata base url\n  // @param:      uri: uri of metadata\n  function setTokenURI(string memory uri) public onlyOwner {\n    _baseTokenURI = uri;\n  }\n\n  // function:    set period of round\n  // @param:      period: period time of round\n  function serPeriod(uint256 _period) public onlyOwner {\n    period = _period;\n  }\n\n  // function:    set treasury wallet address\n  // @param:      to: address of treasury wallet\n  function setTreasuryWallet(address to) public onlyOwner {\n    _treasuryAddr = to;\n  }\n\n  // NTT functions\n\n  // function:    return token uri\n  // @param:      id of token\n  function tokenURI(uint256 _tokenId) public view override returns (string memory) {\n    return _baseTokenURI;\n  }\n\n  // function:    set client seed\n  // param:       seedStr: seed of client\n  function setSeedString(bytes32 seedStr) public hasTicket {\n    clientSeed = keccak256(abi.encodePacked(clientSeed, msg.sender, seedStr));\n  }\n\n  // function:    set token for create betting with this token\n  // @param:      token: address of tokenAddress\n  // @param:      value: true-allow, false-reject\n  function setTokenAllowance(address _token, bool value) public onlyOwner {\n    allowedTokens[_token] = value;\n  }\n\n  // function:    get server seed\n  // @return:     server seed of round\n  function getServerSeed() public view returns (bytes32 serverSeed) {\n    require(currentRound > 0, \"JackPotTicket:NOT_YET\");\n    require(s_randomWords[requestIds[currentRound - 1]].length == 2, \"JackPotTicket:NOT_FINISHED\");\n    return keccak256(abi.encodePacked(s_randomWords[0], s_randomWords[1]));\n  }\n}\n"
    },
    "contracts/utils/VRF/VRFv2Consumer.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// An example of a consumer contract that relies on a subscription for funding.\npragma solidity ^0.8.7;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol\";\nimport \"@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol\";\n\ncontract VRFv2Consumer is VRFConsumerBaseV2 {\n  VRFCoordinatorV2Interface COORDINATOR;\n\n  // Your subscription ID.\n  uint64 public s_subscriptionId;\n\n  // Rinkeby coordinator. For other networks,\n  // see https://docs.chain.link/docs/vrf-contracts/#configurations\n  // address public vrfCoordinator = 0x6168499c0cFfCaCD319c818142124B7A15E857ab;\n\n  // The gas lane to use, which specifies the maximum gas price to bump to.\n  // For a list of available gas lanes on each network,\n  // see https://docs.chain.link/docs/vrf-contracts/#configurations\n  bytes32 public keyHash = 0xd89b2bf150e3b9e13446986e571fb9cab24b13cea0a43ea20a6049a85cc807cc;\n\n  // Depends on the number of requested values that you want sent to the\n  // fulfillRandomWords() function. Storing each word costs about 20,000 gas,\n  // so 100,000 is a safe default for this example contract. Test and adjust\n  // this limit based on the network that you select, the size of the request,\n  // and the processing of the callback request in the fulfillRandomWords()\n  // function.\n  uint32 public callbackGasLimit = 100000;\n\n  // The default is 3, but you can set this higher.\n  uint16 public requestConfirmations = 3;\n\n  // For this example, retrieve 2 random values in one request.\n  // Cannot exceed VRFCoordinatorV2.MAX_NUM_WORDS.\n  uint32 public numWords = 2;\n\n  mapping(uint256 => uint256[]) public s_randomWords;\n\n  constructor(uint64 subscriptionId, address vrfCoordinator) VRFConsumerBaseV2(vrfCoordinator) {\n    COORDINATOR = VRFCoordinatorV2Interface(vrfCoordinator);\n    s_subscriptionId = subscriptionId;\n  }\n\n  // Assumes the subscription is funded sufficiently.\n  function requestRandomWords() internal returns (uint256 requestId) {\n    // Will revert if subscription is not set and funded.\n    requestId = COORDINATOR.requestRandomWords(\n      keyHash,\n      s_subscriptionId,\n      requestConfirmations,\n      callbackGasLimit,\n      numWords\n    );\n  }\n\n  function fulfillRandomWords(\n    uint256 requestId, /* requestId */\n    uint256[] memory randomWords\n  ) internal override {\n    s_randomWords[requestId] = randomWords;\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface VRFCoordinatorV2Interface {\n  /**\n   * @notice Get configuration relevant for making requests\n   * @return minimumRequestConfirmations global min for request confirmations\n   * @return maxGasLimit global max for request gas limit\n   * @return s_provingKeyHashes list of registered key hashes\n   */\n  function getRequestConfig()\n    external\n    view\n    returns (\n      uint16,\n      uint32,\n      bytes32[] memory\n    );\n\n  /**\n   * @notice Request a set of random words.\n   * @param keyHash - Corresponds to a particular oracle job which uses\n   * that key for generating the VRF proof. Different keyHash's have different gas price\n   * ceilings, so you can select a specific one to bound your maximum per request cost.\n   * @param subId  - The ID of the VRF subscription. Must be funded\n   * with the minimum subscription balance required for the selected keyHash.\n   * @param minimumRequestConfirmations - How many blocks you'd like the\n   * oracle to wait before responding to the request. See SECURITY CONSIDERATIONS\n   * for why you may want to request more. The acceptable range is\n   * [minimumRequestBlockConfirmations, 200].\n   * @param callbackGasLimit - How much gas you'd like to receive in your\n   * fulfillRandomWords callback. Note that gasleft() inside fulfillRandomWords\n   * may be slightly less than this amount because of gas used calling the function\n   * (argument decoding etc.), so you may need to request slightly more than you expect\n   * to have inside fulfillRandomWords. The acceptable range is\n   * [0, maxGasLimit]\n   * @param numWords - The number of uint256 random values you'd like to receive\n   * in your fulfillRandomWords callback. Note these numbers are expanded in a\n   * secure way by the VRFCoordinator from a single random value supplied by the oracle.\n   * @return requestId - A unique identifier of the request. Can be used to match\n   * a request to a response in fulfillRandomWords.\n   */\n  function requestRandomWords(\n    bytes32 keyHash,\n    uint64 subId,\n    uint16 minimumRequestConfirmations,\n    uint32 callbackGasLimit,\n    uint32 numWords\n  ) external returns (uint256 requestId);\n\n  /**\n   * @notice Create a VRF subscription.\n   * @return subId - A unique subscription id.\n   * @dev You can manage the consumer set dynamically with addConsumer/removeConsumer.\n   * @dev Note to fund the subscription, use transferAndCall. For example\n   * @dev  LINKTOKEN.transferAndCall(\n   * @dev    address(COORDINATOR),\n   * @dev    amount,\n   * @dev    abi.encode(subId));\n   */\n  function createSubscription() external returns (uint64 subId);\n\n  /**\n   * @notice Get a VRF subscription.\n   * @param subId - ID of the subscription\n   * @return balance - LINK balance of the subscription in juels.\n   * @return reqCount - number of requests for this subscription, determines fee tier.\n   * @return owner - owner of the subscription.\n   * @return consumers - list of consumer address which are able to use this subscription.\n   */\n  function getSubscription(uint64 subId)\n    external\n    view\n    returns (\n      uint96 balance,\n      uint64 reqCount,\n      address owner,\n      address[] memory consumers\n    );\n\n  /**\n   * @notice Request subscription owner transfer.\n   * @param subId - ID of the subscription\n   * @param newOwner - proposed new owner of the subscription\n   */\n  function requestSubscriptionOwnerTransfer(uint64 subId, address newOwner) external;\n\n  /**\n   * @notice Request subscription owner transfer.\n   * @param subId - ID of the subscription\n   * @dev will revert if original owner of subId has\n   * not requested that msg.sender become the new owner.\n   */\n  function acceptSubscriptionOwnerTransfer(uint64 subId) external;\n\n  /**\n   * @notice Add a consumer to a VRF subscription.\n   * @param subId - ID of the subscription\n   * @param consumer - New consumer which can use the subscription\n   */\n  function addConsumer(uint64 subId, address consumer) external;\n\n  /**\n   * @notice Remove a consumer from a VRF subscription.\n   * @param subId - ID of the subscription\n   * @param consumer - Consumer to remove from the subscription\n   */\n  function removeConsumer(uint64 subId, address consumer) external;\n\n  /**\n   * @notice Cancel a subscription\n   * @param subId - ID of the subscription\n   * @param to - Where to send the remaining LINK to\n   */\n  function cancelSubscription(uint64 subId, address to) external;\n}\n"
    },
    "@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/** ****************************************************************************\n * @notice Interface for contracts using VRF randomness\n * *****************************************************************************\n * @dev PURPOSE\n *\n * @dev Reggie the Random Oracle (not his real job) wants to provide randomness\n * @dev to Vera the verifier in such a way that Vera can be sure he's not\n * @dev making his output up to suit himself. Reggie provides Vera a public key\n * @dev to which he knows the secret key. Each time Vera provides a seed to\n * @dev Reggie, he gives back a value which is computed completely\n * @dev deterministically from the seed and the secret key.\n *\n * @dev Reggie provides a proof by which Vera can verify that the output was\n * @dev correctly computed once Reggie tells it to her, but without that proof,\n * @dev the output is indistinguishable to her from a uniform random sample\n * @dev from the output space.\n *\n * @dev The purpose of this contract is to make it easy for unrelated contracts\n * @dev to talk to Vera the verifier about the work Reggie is doing, to provide\n * @dev simple access to a verifiable source of randomness. It ensures 2 things:\n * @dev 1. The fulfillment came from the VRFCoordinator\n * @dev 2. The consumer contract implements fulfillRandomWords.\n * *****************************************************************************\n * @dev USAGE\n *\n * @dev Calling contracts must inherit from VRFConsumerBase, and can\n * @dev initialize VRFConsumerBase's attributes in their constructor as\n * @dev shown:\n *\n * @dev   contract VRFConsumer {\n * @dev     constructor(<other arguments>, address _vrfCoordinator, address _link)\n * @dev       VRFConsumerBase(_vrfCoordinator) public {\n * @dev         <initialization with other arguments goes here>\n * @dev       }\n * @dev   }\n *\n * @dev The oracle will have given you an ID for the VRF keypair they have\n * @dev committed to (let's call it keyHash). Create subscription, fund it\n * @dev and your consumer contract as a consumer of it (see VRFCoordinatorInterface\n * @dev subscription management functions).\n * @dev Call requestRandomWords(keyHash, subId, minimumRequestConfirmations,\n * @dev callbackGasLimit, numWords),\n * @dev see (VRFCoordinatorInterface for a description of the arguments).\n *\n * @dev Once the VRFCoordinator has received and validated the oracle's response\n * @dev to your request, it will call your contract's fulfillRandomWords method.\n *\n * @dev The randomness argument to fulfillRandomWords is a set of random words\n * @dev generated from your requestId and the blockHash of the request.\n *\n * @dev If your contract could have concurrent requests open, you can use the\n * @dev requestId returned from requestRandomWords to track which response is associated\n * @dev with which randomness request.\n * @dev See \"SECURITY CONSIDERATIONS\" for principles to keep in mind,\n * @dev if your contract could have multiple requests in flight simultaneously.\n *\n * @dev Colliding `requestId`s are cryptographically impossible as long as seeds\n * @dev differ.\n *\n * *****************************************************************************\n * @dev SECURITY CONSIDERATIONS\n *\n * @dev A method with the ability to call your fulfillRandomness method directly\n * @dev could spoof a VRF response with any random value, so it's critical that\n * @dev it cannot be directly called by anything other than this base contract\n * @dev (specifically, by the VRFConsumerBase.rawFulfillRandomness method).\n *\n * @dev For your users to trust that your contract's random behavior is free\n * @dev from malicious interference, it's best if you can write it so that all\n * @dev behaviors implied by a VRF response are executed *during* your\n * @dev fulfillRandomness method. If your contract must store the response (or\n * @dev anything derived from it) and use it later, you must ensure that any\n * @dev user-significant behavior which depends on that stored value cannot be\n * @dev manipulated by a subsequent VRF request.\n *\n * @dev Similarly, both miners and the VRF oracle itself have some influence\n * @dev over the order in which VRF responses appear on the blockchain, so if\n * @dev your contract could have multiple VRF requests in flight simultaneously,\n * @dev you must ensure that the order in which the VRF responses arrive cannot\n * @dev be used to manipulate your contract's user-significant behavior.\n *\n * @dev Since the block hash of the block which contains the requestRandomness\n * @dev call is mixed into the input to the VRF *last*, a sufficiently powerful\n * @dev miner could, in principle, fork the blockchain to evict the block\n * @dev containing the request, forcing the request to be included in a\n * @dev different block with a different hash, and therefore a different input\n * @dev to the VRF. However, such an attack would incur a substantial economic\n * @dev cost. This cost scales with the number of blocks the VRF oracle waits\n * @dev until it calls responds to a request. It is for this reason that\n * @dev that you can signal to an oracle you'd like them to wait longer before\n * @dev responding to the request (however this is not enforced in the contract\n * @dev and so remains effective only in the case of unmodified oracle software).\n */\nabstract contract VRFConsumerBaseV2 {\n  error OnlyCoordinatorCanFulfill(address have, address want);\n  address private immutable vrfCoordinator;\n\n  /**\n   * @param _vrfCoordinator address of VRFCoordinator contract\n   */\n  constructor(address _vrfCoordinator) {\n    vrfCoordinator = _vrfCoordinator;\n  }\n\n  /**\n   * @notice fulfillRandomness handles the VRF response. Your contract must\n   * @notice implement it. See \"SECURITY CONSIDERATIONS\" above for important\n   * @notice principles to keep in mind when implementing your fulfillRandomness\n   * @notice method.\n   *\n   * @dev VRFConsumerBaseV2 expects its subcontracts to have a method with this\n   * @dev signature, and will call it once it has verified the proof\n   * @dev associated with the randomness. (It is triggered via a call to\n   * @dev rawFulfillRandomness, below.)\n   *\n   * @param requestId The Id initially returned by requestRandomness\n   * @param randomWords the VRF output expanded to the requested number of words\n   */\n  function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) internal virtual;\n\n  // rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF\n  // proof. rawFulfillRandomness then calls fulfillRandomness, after validating\n  // the origin of the call\n  function rawFulfillRandomWords(uint256 requestId, uint256[] memory randomWords) external {\n    if (msg.sender != vrfCoordinator) {\n      revert OnlyCoordinatorCanFulfill(msg.sender, vrfCoordinator);\n    }\n    fulfillRandomWords(requestId, randomWords);\n  }\n}\n"
    },
    "contracts/quickbux/QbuxVault.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol\";\n\ncontract QBuxVault is Ownable {\n  address public erc20token;\n  IUniswapV2Router01 public router;\n  address public authorizer;\n  uint256 exchange_rate;\n  mapping(address => uint256) public last_signed_nonce;\n  mapping(address => bool) public approvedToken;\n  uint256 vaultUSD;\n\n  address vaultFees;\n  uint256 withdrawPercentage;\n\n  uint256 private constant _MAX_UINT256 = type(uint256).max;\n\n  event Deposit(\n    address indexed account,\n    uint256 indexed timestamp,\n    uint256 usdValue,\n    uint256 value\n  );\n  event Withdraw(\n    address indexed account,\n    uint256 indexed timestamp,\n    uint256 usdValue,\n    uint256 value\n  );\n  event WithdrawVault(address indexed to, uint256 usdValue);\n\n  struct Sig {\n    bytes32 r;\n    bytes32 s;\n    uint8 v;\n  }\n\n  function _validRedeemParam(\n    address account,\n    uint256 value,\n    uint256 timestamp,\n    Sig calldata signature\n  ) private view returns (bool) {\n    bytes32 messageHash = keccak256(abi.encodePacked(account, value, timestamp));\n    bytes32 ethSignedMessageHash = keccak256(\n      abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", messageHash)\n    );\n\n    return ecrecover(ethSignedMessageHash, signature.v, signature.r, signature.s) == authorizer;\n  }\n\n  constructor(\n    address _erc20token,\n    address _authorizer,\n    address _router,\n    uint256 _exchange_rate\n  ) {\n    erc20token = _erc20token;\n    authorizer = _authorizer;\n    router = IUniswapV2Router01(_router);\n    exchange_rate = _exchange_rate;\n\n    IERC20(_erc20token).approve(address(_router), _MAX_UINT256);\n  }\n\n  function setAuthorizer(address new_authorizer) public onlyOwner {\n    authorizer = new_authorizer;\n  }\n\n  function setExchangeRate(uint256 _exchange_rate) public onlyOwner {\n    exchange_rate = _exchange_rate;\n  }\n\n  function setApprovedToken(address token, bool approve) public onlyOwner {\n    approvedToken[token] = approve;\n    if (approve) {\n      IERC20(token).approve(address(router), _MAX_UINT256);\n    } else {\n      IERC20(token).approve(address(router), 0);\n    }\n  }\n\n  function setWithdrawFees(address vault, uint256 fee) public onlyOwner {\n    vaultFees = vault;\n    withdrawPercentage = fee;\n  }\n\n  function deposit(address token, uint256 value_token) public onlyApprovedToken(token) {\n    uint256 converted = value_token * exchange_rate;\n    vaultUSD += value_token;\n\n    if (token == erc20token) {\n      IERC20(token).transferFrom(msg.sender, address(this), value_token);\n    } else {\n      address[] memory path = new address[](2);\n      path[0] = token;\n      path[1] = erc20token;\n\n      uint256[] memory amounts = router.getAmountsIn(value_token, path);\n\n      IERC20(token).transferFrom(msg.sender, address(this), amounts[0]);\n      router.swapTokensForExactTokens(value_token, amounts[0], path, address(this), _MAX_UINT256);\n    }\n\n    emit Deposit(msg.sender, block.timestamp, value_token, converted);\n  }\n\n  function withdraw(\n    address token,\n    address account,\n    uint256 value_qbux,\n    uint256 timestamp,\n    Sig calldata signature\n  ) public onlyApprovedToken(token) {\n    require(block.timestamp - timestamp < 600, \"QBuxVault:OLD_SIGNATURE\");\n    require(\n      _validRedeemParam(account, value_qbux, timestamp, signature),\n      \"QBuxVault:INVALID_SIGNATURE\"\n    );\n    require(last_signed_nonce[account] != timestamp, \"QBuxVault:NONCE_USED\");\n\n    uint256 converted = value_qbux / exchange_rate;\n    if (withdrawPercentage > 0) {\n      converted -= converted * (withdrawPercentage / 10000);\n    }\n\n    vaultUSD -= converted;\n    last_signed_nonce[account] = timestamp;\n\n    if (token == erc20token) {\n      IERC20(token).transfer(account, converted);\n    } else {\n      address[] memory path = new address[](2);\n      path[0] = erc20token;\n      path[1] = token;\n\n      router.swapExactTokensForTokens(converted, 0, path, account, _MAX_UINT256);\n    }\n\n    emit Withdraw(account, timestamp, converted, value_qbux);\n  }\n\n  function withdrawVault(address to, uint256 amount) external {\n    require(msg.sender == vaultFees, \"QBuxValut:NOT_VAULT\");\n    require(amount <= vaultUSD, \"QBuxValut:INSUFFICIENT_USD\");\n    vaultUSD -= amount;\n    IERC20(erc20token).transfer(to, amount);\n    emit WithdrawVault(to, amount);\n  }\n\n  modifier onlyApprovedToken(address token) {\n    require(approvedToken[token], \"QBuxValut:TOKEN_NOT_APPROVED\");\n    _;\n  }\n}\n"
    },
    "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol": {
      "content": "pragma solidity >=0.6.2;\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n"
    },
    "contracts/gwit/old/Vesting.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.9;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {AccessControl} from \"../../utils/AccessControl.sol\";\n\ncontract GwitVesting is AccessControl {\n  //Address of signer\n  address public immutable signer;\n  //Address of GWIT\n  address public immutable gwit;\n  //Address of pGWIT\n  address public immutable pGwit;\n\n  Term[] terms;\n\n  mapping(uint256 => mapping(address => uint256)) public deposits;\n  mapping(uint256 => mapping(address => uint256)) public releases;\n\n  struct Term {\n    uint32 start;\n    uint32 duration;\n    uint256 supply;\n    uint256 released;\n  }\n\n  struct Sig {\n    bytes32 r;\n    bytes32 s;\n    uint8 v;\n  }\n\n  constructor(\n    address signer_,\n    address gwit_,\n    address pGwit_\n  ) {\n    signer = signer_;\n    gwit = gwit_;\n    pGwit = pGwit_;\n  }\n\n  function register(\n    uint256 id,\n    uint256 amount,\n    Sig calldata sig\n  ) external whenNotPaused {\n    require(_isParamValid(id, sig), \"Invalid parameter\");\n    deposits[id][msg.sender] += amount;\n    IERC20(pGwit).transferFrom(msg.sender, address(this), amount);\n  }\n\n  function claim(uint256 id, address recipient) external {\n    uint256 amount = getClaimable(id, msg.sender);\n\n    Term storage term = terms[id];\n    term.released += amount;\n    releases[id][msg.sender] += amount;\n\n    IERC20(gwit).transfer(recipient, amount);\n  }\n\n  function getClaimable(uint256 id, address user) public view returns (uint256) {\n    Term memory term = terms[id];\n    uint32 currentTime = uint32(block.timestamp);\n    if (currentTime <= term.start) {\n      return 0;\n    }\n    uint256 amount = ((currentTime - term.start) * deposits[id][user]) /\n      term.duration -\n      releases[id][user];\n    return amount;\n  }\n\n  function createTerm(\n    uint32 start,\n    uint32 duration,\n    uint256 supply\n  ) external onlyOwner {\n    Term memory term = Term(start, duration, supply, 0);\n    terms.push(term);\n    IERC20(gwit).transferFrom(msg.sender, address(this), supply);\n  }\n\n  function updateTerm(\n    uint256 id,\n    uint32 start,\n    uint32 duration,\n    uint256 supply\n  ) external onlyOwner {\n    Term memory term = terms[id];\n\n    if (block.timestamp < term.start) {\n      term.start = start;\n      term.duration = duration;\n    }\n\n    term.supply = supply;\n    if (supply < term.supply) {\n      IERC20(gwit).transfer(msg.sender, term.supply - supply);\n    } else {\n      IERC20(gwit).transferFrom(msg.sender, address(this), supply - term.supply);\n    }\n\n    terms[id] = term;\n  }\n\n  function _isParamValid(uint256 id, Sig calldata sig) private view returns (bool) {\n    bytes32 messageHash = keccak256(abi.encodePacked(msg.sender, id));\n    bytes32 ethSignedMessageHash = keccak256(\n      abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", messageHash)\n    );\n    return ecrecover(ethSignedMessageHash, sig.v, sig.r, sig.s) == signer;\n  }\n}\n"
    },
    "contracts/utils/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.9;\n\nimport {Pausable} from \"@openzeppelin/contracts/security/Pausable.sol\";\n\ncontract AccessControl is Pausable {\n  //Address of current owner\n  address public owner;\n  //Address of new owner (Note: new owner must pull to be an owner)\n  address public newOwner;\n  //Maps if user has minter role\n  mapping(address => bool) public isMinter;\n\n  //Fires when new owner is pushed\n  event OwnerPushed(address indexed pushedOwner);\n  //Fires when new owner pulled\n  event OwnerPulled(address indexed previousOwner, address indexed newOwner);\n  //Fires when minter role is granted\n  event MinterRoleGranted(address indexed account);\n  //Fires when minter role is revoked\n  event MinterRoleRevoked(address indexed account);\n\n  constructor() {\n    owner = msg.sender;\n    emit OwnerPulled(address(0), msg.sender);\n  }\n\n  modifier onlyOwner() {\n    require(msg.sender == owner, \"Only owner\");\n    _;\n  }\n\n  modifier onlyMinter() {\n    require(isMinter[msg.sender], \"Only minter\");\n    _;\n  }\n\n  function pushOwner(address account) public onlyOwner {\n    require(account != address(0), \"No address(0)\");\n    require(account != owner, \"Only new owner\");\n    newOwner = account;\n    emit OwnerPushed(account);\n  }\n\n  function pullOwner() external {\n    require(msg.sender == newOwner, \"Only new owner\");\n    address oldOwner = owner;\n    owner = msg.sender;\n    emit OwnerPulled(oldOwner, msg.sender);\n  }\n\n  function grantMinterRole(address account) external onlyOwner {\n    require(account != address(0), \"No address(0)\");\n    require(!isMinter[account], \"Already granted\");\n    isMinter[account] = true;\n    emit MinterRoleGranted(account);\n  }\n\n  function revokeMinterRole(address account) external onlyOwner {\n    require(isMinter[account], \"Not granted\");\n    isMinter[account] = false;\n    emit MinterRoleRevoked(account);\n  }\n\n  function pause() external onlyOwner {\n    _pause();\n  }\n\n  function unpause() external onlyOwner {\n    _unpause();\n  }\n}\n"
    },
    "@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "contracts/rooster/old/OldRooster.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC1155/extensions/ERC1155Burnable.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n\ncontract RoosterOld is ERC1155Burnable, Pausable, Ownable {\n  mapping(address => bool) public isOperator;\n  mapping(uint256 => BaseStats) public baseStats;\n\n  event UpdateOperator(address user, bool isOperator);\n\n  struct BaseStats {\n    uint32 VIT;\n    uint32 WATK;\n    uint32 BATK;\n    uint32 CATK;\n    uint32 SPD;\n    uint32 AGRO;\n  }\n\n  constructor() ERC1155(\"Rooster\") {\n    isOperator[msg.sender] = true;\n  }\n\n  modifier onlyOperator() {\n    require(isOperator[_msgSender()], \"Invalid access\");\n    _;\n  }\n\n  function mint(\n    address account,\n    uint256 id,\n    uint256 amount,\n    bytes memory data\n  ) public onlyOperator {\n    _mint(account, id, amount, data);\n  }\n\n  function mintBatch(\n    address to,\n    uint256[] memory ids,\n    uint256[] memory amounts,\n    bytes memory data\n  ) public onlyOperator {\n    _mintBatch(to, ids, amounts, data);\n  }\n\n  /* Admin settings  */\n  function setOperator(address user, bool isOperator_) external onlyOwner {\n    isOperator[user] = isOperator_;\n    emit UpdateOperator(user, isOperator_);\n  }\n\n  function setURI(string memory newuri) public onlyOperator {\n    _setURI(newuri);\n  }\n\n  function setBaseStats(uint256 id, BaseStats memory newStats) external onlyOperator {\n    baseStats[id] = newStats;\n  }\n\n  function pause() public onlyOperator {\n    _pause();\n  }\n\n  function unpause() public onlyOperator {\n    _unpause();\n  }\n\n  function _beforeTokenTransfer(\n    address operator,\n    address from,\n    address to,\n    uint256[] memory ids,\n    uint256[] memory amounts,\n    bytes memory data\n  ) internal override whenNotPaused {\n    super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\n  }\n\n  function supportsInterface(bytes4 interfaceId) public view override(ERC1155) returns (bool) {\n    return super.supportsInterface(interfaceId);\n  }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/extensions/ERC1155Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/ERC1155Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1155.sol\";\n\n/**\n * @dev Extension of {ERC1155} that allows token holders to destroy both their\n * own tokens and those that they have been approved to use.\n *\n * _Available since v3.1._\n */\nabstract contract ERC1155Burnable is ERC1155 {\n    function burn(\n        address account,\n        uint256 id,\n        uint256 value\n    ) public virtual {\n        require(\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n\n        _burn(account, id, value);\n    }\n\n    function burnBatch(\n        address account,\n        uint256[] memory ids,\n        uint256[] memory values\n    ) public virtual {\n        require(\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n\n        _burnBatch(account, ids, values);\n    }\n}\n"
    },
    "contracts/egg/Egg.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\n\n\n//\n\n//solhint-disable avoid-low-level-calls\ncontract RoosterEgg is ERC721, ERC721Burnable, Ownable, Pausable {\n  using Strings for uint256;\n\n  // Presale time in UNIX\n  uint32 public openingTime;\n  uint32 public closingTime;\n\n  //Max supply for round\n  uint24 public supply;\n\n  //Tokens sold for round\n  uint24 public sold;\n\n  //Indivisual cap for round\n  uint24 public cap;\n\n  //Current tokenID count\n  uint24 private _tokenIdCounter;\n\n  //The price per egg (1egg = ? wei)\n  uint256 public price;\n\n  //Matic cashback per egg\n  uint256 public cashbackPerEgg;\n\n  //USDC address\n  IERC20 public immutable usdc;\n\n  // Vault wallet address\n  address public immutable wallet;\n\n  //Base URI\n  string public baseURI;\n\n  //user => amount\n  mapping(address => uint8) public purchasedAmount;\n\n  event Purchase(address indexed purchaser, uint8 amount, uint256 value);\n  event NewPresale(\n    uint24 supply,\n    uint24 cap,\n    uint32 openingTime,\n    uint32 closingTime,\n    uint256 price,\n    uint256 cashbackPerEgg\n  );\n  event MaticReceived(address user, uint256 amount);\n  event MaticWithdrawn(uint256 amount);\n  event MaticCashback(address user, uint256 amount);\n  event MaticCashbackFailed(address indexed user, uint256 balance);\n\n  constructor(\n    IERC20 usdc_,\n    address wallet_,\n    uint24 inititalTokenId_,\n    string memory baseURI_\n  ) ERC721(\"RoosterEgg\", \"ROOSTER_EGG\") {\n    usdc = usdc_;\n    wallet = wallet_;\n    baseURI = baseURI_;\n    _tokenIdCounter = inititalTokenId_;\n  }\n\n  receive() external payable {\n    emit MaticReceived(msg.sender, msg.value);\n  }\n\n  function isOpen() public view returns (bool) {\n    return block.timestamp >= openingTime && block.timestamp <= closingTime;\n  }\n\n  function getTime() external view returns (uint32) {\n    return uint32(block.timestamp);\n  }\n\n  function tokenURI(uint256 tokenId) public view override returns (string memory) {\n    require(bytes(baseURI).length > 0, \"BaseURI not set\");\n    require(_exists(tokenId), \"Query for nonexistent token\");\n    return string(abi.encodePacked(baseURI, tokenId.toString()));\n  }\n\n  function _baseURI() internal view override returns (string memory) {\n    return baseURI;\n  }\n\n  function buyEggs(uint8 amount) external {\n    address purchaser = _msgSender();\n    uint256 value = price * amount;\n    uint256 cashbackAmount = cashbackPerEgg * amount;\n\n    //Checks\n    _preValidatePurchase(purchaser, amount);\n\n    //Effects\n    sold += amount;\n    purchasedAmount[purchaser] += amount;\n\n    //Interactions\n    usdc.transferFrom(purchaser, wallet, value);\n    _mintEggs(purchaser, amount);\n\n    (bool success, ) = payable(purchaser).call{value: cashbackAmount}(\"\");\n    if (success) {\n      emit MaticCashback(purchaser, cashbackAmount);\n    } else {\n      emit MaticCashbackFailed(purchaser, address(this).balance);\n    }\n\n    emit Purchase(purchaser, amount, value);\n  }\n\n  function burnBatch(uint24[] calldata tokenIds) external {\n    for (uint256 i = 0; i < tokenIds.length; i++) {\n      burn(tokenIds[i]);\n    }\n  }\n\n  function _preValidatePurchase(address purchaser, uint8 amount) private view whenNotPaused {\n    require(isOpen(), \"Not open\");\n    require(sold + amount <= supply, \"Exceeds supply\");\n    require(amount + purchasedAmount[purchaser] <= cap, \"Exceeds cap\");\n  }\n\n  function _mintEggs(address to, uint256 amount) private {\n    uint24 newtokenId = _tokenIdCounter;\n\n    for (uint256 i = 0; i < amount; i++) {\n      _safeMint(to, newtokenId++);\n    }\n\n    _tokenIdCounter = newtokenId;\n  }\n\n  /* Only owner functions */\n\n  function setPresale(\n    uint32 openingTime_,\n    uint32 closingTime_,\n    uint24 supply_,\n    uint24 cap_,\n    uint256 price_,\n    uint256 cashbackPerEgg_\n  ) external onlyOwner {\n    require(!isOpen() || paused(), \"Cannot set now\");\n    if (!isOpen()) {\n      require(closingTime_ >= openingTime_, \"Closing time < Opening time\");\n      require(openingTime_ > block.timestamp, \"Invalid opening time\");\n      openingTime = openingTime_;\n    }\n\n    supply = supply_;\n    cap = cap_;\n    price = price_;\n    closingTime = closingTime_;\n    cashbackPerEgg = cashbackPerEgg_;\n\n    emit NewPresale(supply_, cap_, openingTime_, closingTime_, price_, cashbackPerEgg_);\n  }\n\n  function mintEggs(address to, uint256 amount) external onlyOwner {\n    _mintEggs(to, amount);\n  }\n\n  function setBaseURI(string memory baseURI_) external onlyOwner {\n    baseURI = baseURI_;\n  }\n\n  function withdrawMatic(uint256 amount) external {\n    address user = msg.sender;\n    require(user == owner() || user == wallet, \"Invalid access\");\n    (bool success, ) = payable(wallet).call{value: amount}(\"\");\n    require(success, \"Withdraw failed\");\n    emit MaticWithdrawn(amount);\n  }\n\n  function pause() external onlyOwner {\n    _pause();\n  }\n\n  function unpause() external onlyOwner {\n    _unpause();\n  }\n}\n"
    },
    "contracts/egg/EggSale.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../utils/AccessControl.sol\";\n\n//\n\ninterface Egg {\n  function mintEggs(address to, uint256 amount) external;\n\n  function setBaseURI(string memory baseURI_) external;\n\n  function transferOwnership(address newOwner) external;\n\n  function purchasedAmount(address user) external view returns (uint8);\n}\n\n//solhint-disable avoid-low-level-calls\ncontract RoosterEggSale is AccessControl {\n  //EggSale struct\n  EggSale public eggsale;\n\n  //RoosterEgg address\n  Egg public immutable egg;\n\n  //USDC address\n  IERC20 public immutable usdc;\n\n  //Vault address\n  address public immutable vault;\n\n  //Whitelist verification signer address\n  address public immutable signer;\n\n  //Total minted\n  uint256 public minted;\n\n  //Max supply of eggs\n  uint256 public constant maxSupply = 150_000;\n\n  //User egg purchased amount (user => amount)\n  mapping(address => uint256) public purchasedAmount;\n  //Check if nonce is used (nonce => boolean)\n  mapping(bytes32 => bool) private _nonceUsed;\n\n  // for affiliate sale\n  // address of affiliate contract\n  address private affiliateAddress;\n  // price of affiliate sale\n  uint256 public affiliatePrice;\n\n  event Purchase(address indexed purchaser, uint256 amount, uint256 value);\n  event EggSaleSet(\n    uint256 supply,\n    uint256 cap,\n    uint256 openingTime,\n    uint256 closingTime,\n    bool whitelist,\n    uint256 price,\n    uint256 cashback\n  );\n  event MaticCashback(address user, uint256 amount);\n  event MaticCashbackFailed(address indexed user, uint256 balance);\n\n  struct EggSale {\n    uint32 supply;\n    uint32 cap;\n    uint32 sold;\n    uint32 openingTime;\n    uint32 closingTime;\n    bool whitelist;\n    uint256 price;\n    uint256 cashback;\n  }\n\n  struct Sig {\n    bytes32 r;\n    bytes32 s;\n    uint8 v;\n  }\n\n  constructor(\n    address usdc_,\n    address egg_,\n    address vault_,\n    address signer_,\n    uint256 minted_\n  ) {\n    usdc = IERC20(usdc_);\n    egg = Egg(egg_);\n    vault = vault_;\n    signer = signer_;\n    minted = minted_;\n  }\n\n  receive() external payable {}\n\n  function isOpen() public view returns (bool) {\n    return block.timestamp >= eggsale.openingTime && block.timestamp < eggsale.closingTime;\n  }\n\n  function buyEggs(\n    uint8 amount,\n    bytes32 nonce,\n    Sig calldata sig\n  ) external whenNotPaused {\n    address purchaser = msg.sender;\n    uint256 value = eggsale.price * amount;\n    uint256 cashbackAmount = eggsale.cashback * amount;\n\n    //Basic chekcs\n    require(isOpen(), \"Not open\");\n    require(minted + amount <= maxSupply, \"Exceeds max supply\");\n    require(eggsale.sold + amount <= eggsale.supply, \"Exceeds supply\");\n    require(\n      purchasedAmount[purchaser] + egg.purchasedAmount(purchaser) + amount <= eggsale.cap,\n      \"Exceeds cap\"\n    );\n\n    //Whitelist check\n    if (eggsale.whitelist) {\n      require(!_nonceUsed[nonce], \"Nonce used\");\n      require(_isWhitelisted(purchaser, nonce, sig), \"Not whitelisted\");\n      _nonceUsed[nonce] = true;\n    }\n\n    //Effects\n    unchecked {\n      minted += amount;\n      eggsale.sold += amount;\n      purchasedAmount[purchaser] += amount;\n    }\n\n    //Interactions\n    usdc.transferFrom(purchaser, vault, value);\n\n    egg.mintEggs(purchaser, amount);\n\n    if (cashbackAmount > 0) {\n      (bool success, ) = payable(purchaser).call{value: cashbackAmount}(\"\");\n      if (success) {\n        emit MaticCashback(purchaser, cashbackAmount);\n      } else {\n        emit MaticCashbackFailed(purchaser, address(this).balance);\n      }\n    }\n\n    emit Purchase(purchaser, amount, value);\n  }\n\n  function _isWhitelisted(\n    address user,\n    bytes32 nonce,\n    Sig calldata sig\n  ) private view returns (bool) {\n    bytes32 messageHash = keccak256(abi.encodePacked(user, nonce));\n    bytes32 ethSignedMessageHash = keccak256(\n      abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", messageHash)\n    );\n\n    return ecrecover(ethSignedMessageHash, sig.v, sig.r, sig.s) == signer;\n  }\n\n  /* Only owner functions */\n\n  function setEggSale(\n    uint32 openingTime,\n    uint32 closingTime,\n    uint32 supply,\n    uint32 cap,\n    bool whitelist,\n    uint256 price,\n    uint256 cashback\n  ) external onlyOwner {\n    require(closingTime >= openingTime, \"Closing time < Opening time\");\n\n    if (!isOpen()) {\n      require(openingTime > block.timestamp, \"Invalid opening time\");\n      eggsale.openingTime = openingTime;\n      eggsale.sold = 0;\n    }\n\n    eggsale.closingTime = closingTime;\n    eggsale.supply = supply;\n    eggsale.cap = cap;\n    eggsale.whitelist = whitelist;\n    eggsale.price = price;\n    eggsale.cashback = cashback;\n\n    emit EggSaleSet(supply, cap, openingTime, closingTime, whitelist, price, cashback);\n  }\n\n  function mintEggs(address to, uint256 amount) external onlyMinter {\n    require(minted + amount <= maxSupply, \"Exceeds max supply\");\n    unchecked {\n      minted += amount;\n    }\n    egg.mintEggs(to, amount);\n  }\n\n  function setBaseURI(string memory baseURI_) external onlyOwner {\n    egg.setBaseURI(baseURI_);\n  }\n\n  function withdrawMatic(uint256 amount) external onlyOwner {\n    (bool success, ) = payable(vault).call{value: amount}(\"\");\n    require(success, \"Withdraw failed\");\n  }\n\n  function transferEggContractOwnership(address newOwner) external onlyOwner {\n    egg.transferOwnership(newOwner);\n  }\n\n  // for affiliate sell\n  function setAffiliateData(address _address, uint256 _price) public onlyOwner {\n    affiliateAddress = _address;\n    affiliatePrice = _price;\n  }\n\n  modifier onlyAffiliate() {\n\n    require(msg.sender == affiliateAddress, \"EggSale:NOT_AFFILIATE\");\n    _;\n  }\n\n  function buyEggWithAffiliate(\n    address from,\n    address to,\n    uint256 amount\n  ) public onlyAffiliate {\n    //Interactions\n    usdc.transferFrom(from, vault, affiliatePrice * amount);\n    bytes memory callData = abi.encodeWithSelector(egg.mintEggs.selector, to, amount);\n    (bool success, ) = address(egg).call(callData);\n\n    if (!success) revert(\"mint reverted\");\n  }\n}\n"
    },
    "contracts/gwit/GwitVesting.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {Auth} from \"../utils/Auth.sol\";\n\n\ncontract GwitVesting is Auth {\n  //Gwit vesting info\n  Info public info;\n  //pGWIT address\n  IERC20 public immutable aGwit;\n  //GWIT address\n  IERC20 public immutable gwit;\n  //released amount\n  uint256 public released;\n\n  //user redeemed amount\n  mapping(address => uint256) public redeemed;\n\n  struct Info {\n    //start time of the vesting period\n    uint32 start;\n    //cliff period in seconds\n    uint32 cliff;\n    //duration of vesting period\n    uint32 duration;\n    //initial release at start time in hundreds ( 500 = 5% )\n    uint32 initialRate;\n  }\n\n  event Redeem(address indexed user, address indexed recipient, uint256 amount);\n  event Set(uint32 start, uint32 cliff, uint32 duration, uint32 initialRate);\n  event Withdraw(address indexed user, uint256 amount, uint256 balance);\n\n  error ExceedsLimit(uint256 limit);\n  error ExceedsSupply();\n  error InvalidStartingTime();\n  error CannotWithdrawDuringVestingPeriod();\n\n  constructor(address aGwit_, address gwit_) {\n    aGwit = IERC20(aGwit_);\n    gwit = IERC20(gwit_);\n  }\n\n  function redeemable(address user) public view returns (uint256) {\n    return vestedAmount(user) - redeemed[user];\n  }\n\n  function vestedAmount(address user) public view returns (uint256) {\n    uint256 total = aGwit.balanceOf(user);\n    uint32 currentTime = uint32(block.timestamp);\n    Info memory _info = info;\n\n    if (currentTime < _info.start) {\n      return 0;\n    } else if (currentTime < _info.start + _info.duration) {\n      uint256 initial = (total * _info.initialRate) / 10_000;\n      if (currentTime < _info.start + _info.cliff) {\n        return initial;\n      } else {\n        return ((currentTime - _info.start) * (total - initial)) / _info.duration + initial;\n      }\n    } else {\n      return total;\n    }\n  }\n\n  function redeem(address recipient, uint256 amount) external whenNotPaused {\n    address user = msg.sender;\n    uint256 maxAmount = redeemable(user);\n\n    if (amount > 0) {\n      if (amount > maxAmount) revert ExceedsLimit(maxAmount);\n    } else {\n      amount = maxAmount;\n    }\n    if (amount > gwit.balanceOf(address(this))) revert ExceedsSupply();\n\n    unchecked {\n      released += amount;\n      redeemed[user] += amount;\n    }\n\n    gwit.transfer(recipient, amount);\n\n    emit Redeem(user, recipient, amount);\n  }\n\n  function set(\n    uint32 start,\n    uint32 cliff,\n    uint32 duration,\n    uint32 initialRate\n  ) external onlyOwner {\n    if (start < block.timestamp) revert InvalidStartingTime();\n    info = Info(start, cliff, duration, initialRate);\n    emit Set(start, cliff, duration, initialRate);\n  }\n\n  function withdraw(uint256 amount) external onlyRole(\"VAULT\") {\n    Info memory _info = info;\n    if (block.timestamp >= _info.start && block.timestamp <= _info.start + _info.duration) {\n      revert CannotWithdrawDuringVestingPeriod();\n    }\n    gwit.transfer(msg.sender, amount);\n    emit Withdraw(msg.sender, amount, gwit.balanceOf(address(this)));\n  }\n}\n"
    },
    "contracts/gwit/AlphaGwitSale.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC20Permit} from \"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\";\nimport {Auth} from \"../utils/Auth.sol\";\n\ninterface AlphaGwit {\n  function mint(address to, uint256 amount) external;\n}\n\ncontract AlphaGwitSale is Auth {\n  //AlphaGwitSale info\n  Info public info;\n\n  //USDC address\n  IERC20 public immutable usdc;\n\n  //aGWIT address\n  AlphaGwit public immutable aGwit;\n\n  //Vault address\n  address public immutable vault;\n\n  //User purchased amount (user => amount)\n  mapping(address => uint256) public amounts;\n\n  struct Info {\n    uint32 openingTime;\n    uint32 closingTime;\n    uint256 supply;\n    uint256 cap;\n    uint256 sold;\n    uint256 price;\n  }\n\n  struct Sig {\n    bytes32 r;\n    bytes32 s;\n    uint8 v;\n  }\n\n  //Fires when sale is set\n  event Set(uint256 openingTime, uint256 closingTime, uint256 supply, uint256 cap, uint256 price);\n\n  //Fires when aGwit purchase has been made\n  event Buy(\n    address indexed purchaser,\n    address recipient,\n    uint256 amount,\n    uint256 value,\n    bytes32 data\n  );\n\n  error NotOpen();\n  error ExceedsSupply();\n  error ExceedsCap();\n  error InvalidTimeWindow();\n  error InvalidOpeningTime();\n\n  constructor(\n    address usdc_,\n    address aGwit_,\n    address vault_\n  ) {\n    aGwit = AlphaGwit(aGwit_);\n    usdc = IERC20(usdc_);\n    vault = vault_;\n  }\n\n  function isOpen() public view returns (bool) {\n    return block.timestamp >= info.openingTime && block.timestamp < info.closingTime;\n  }\n\n  function buy(\n    address recipient,\n    uint256 amount,\n    uint256 deadline,\n    Sig calldata sig,\n    bytes32 data\n  ) external whenNotPaused {\n    Info memory _info = info;\n    address purchaser = msg.sender;\n    uint256 value = (_info.price * amount) / 1e18;\n\n    if (!isOpen()) revert NotOpen();\n    if (_info.sold + amount > _info.supply) revert ExceedsSupply();\n    if (amounts[purchaser] + amount > _info.cap) revert ExceedsCap();\n\n    info.sold += amount;\n    amounts[purchaser] += amount;\n\n    if (deadline != 0) {\n      IERC20Permit permit = IERC20Permit(address(usdc));\n      permit.permit(purchaser, address(this), value, deadline, sig.v, sig.r, sig.s);\n    }\n\n    usdc.transferFrom(purchaser, vault, value);\n    aGwit.mint(recipient, amount);\n\n    emit Buy(purchaser, recipient, amount, value, data);\n  }\n\n  function set(\n    uint32 openingTime,\n    uint32 closingTime,\n    uint256 supply,\n    uint256 cap,\n    uint256 price\n  ) external onlyOwner {\n    if (closingTime <= openingTime) revert InvalidTimeWindow();\n\n    Info memory _info = info;\n\n    if (!isOpen()) {\n      if (openingTime < block.timestamp) revert InvalidOpeningTime();\n      _info.openingTime = openingTime;\n      _info.sold = 0;\n    }\n\n    _info.closingTime = closingTime;\n    _info.supply = supply;\n    _info.cap = cap;\n    _info.price = price;\n\n    info = _info;\n\n    emit Set(openingTime, closingTime, supply, cap, price);\n  }\n}\n"
    },
    "contracts/betting/FightBetting.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.9;\n\nimport {Auth} from \"../utils/Auth.sol\";\nimport {IFightBetting} from \"./IFightBetting.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\ninterface IJackPot {\n  function mintTo(uint256 amount, address to) external;\n}\n\ncontract FightBetting is Auth, IFightBetting {\n  using SafeERC20 for IERC20;\n  // address of jackpot\n  address public jackpotAddr;\n  // betting data array\n  Betting[] public bettings;\n  // betting state array\n  BettingState[] public bettingStates;\n  // seed data array\n  SeedData[] private seedData;\n  // bettors array\n  // bettingId => bettor[]\n  mapping(uint256 => Bettor[]) public bettors;\n  // shows lucky winner withdrawed their reward\n  uint8[] public luckyWinnerStates;\n  // who has betted which betting\n  // bettingId => (bettor => true|false)\n  mapping(uint256 => mapping(address => bool)) private betted;\n  // shows how mauch token has eaned by betting\n  // token address => amount\n  mapping(address => uint256) private tokenAmounts;\n  // shows the minimum value for jackpot tickets\n  uint256 public minBetNumForJackPot;\n  // shows how much he played this betting\n  // bettor address => betting count\n  mapping(address => uint256) public betNumber;\n  // shows which token can use this betting\n  // token address => true|false\n  mapping(address => bool) public allowedTokens;\n\n  // modifier: verify bettor can bet to this betting(bettingId) with this value(value)\n  // @param   bettingId:  current betting id\n  // @param   value:      betting amount\n  modifier canBet(uint256 bettingId, uint256 value) {\n    require(bettingId < bettings.length, \"FightBetting:NOT_CREATED\");\n    require(block.timestamp >= bettings[bettingId].startTime, \"FightBetting:NOT_STARTED_YET\");\n    require(block.timestamp < bettings[bettingId].endTime, \"FightBetting:ALREADY_FINISHED\");\n    require(value >= bettings[bettingId].minAmount, \"FightBetting:TOO_SMALL_AMOUNT\");\n    require(value <= bettings[bettingId].maxAmount, \"FightBetting:TOO_MUCH_AMOUNT\");\n    require(betted[bettingId][msg.sender] != true, \"FightBetting:ALREADY_BET\");\n\n    _;\n  }\n\n  // fight betting contract creates with jackpot address\n  constructor(address jackpot) {\n    jackpotAddr = jackpot;\n    minBetNumForJackPot = 1000;\n  }\n\n  // function:  creates a betting\n  // @param   fighter1: first fighter id\n  // @param   fighter2: second fighter id\n  // @param   startTime: when the bet starts\n  // @param   endTime: when the bet ends.\n  // @param   minAmount: minimum amount can bet\n  // @param   maxAmount: maximum amount can bet\n  // @param   tokenAddr: address of token can bet\n  // @param   hashedServerSeed: hash of server seed value\n  // @param   sig: signer signature for the access\n  function createBetting(\n    uint256 fighter1,\n    uint256 fighter2,\n    uint32 startTime,\n    uint32 endTime,\n    uint256 minAmount,\n    uint256 maxAmount,\n    address tokenAddr,\n    bytes32 hashedServerSeed,\n    Sig calldata sig\n  ) external onlyRole(\"MAINTAINER\") {\n    require(\n      _isCreateParamValid(\n        fighter1,\n        fighter2,\n        startTime,\n        endTime,\n        minAmount,\n        maxAmount,\n        tokenAddr,\n        hashedServerSeed,\n        sig\n      ),\n      \"FightBetting:INVALID_PARAM\"\n    );\n    require(allowedTokens[tokenAddr], \"FightBetting:INVALID_TOKEN\");\n    require(startTime < endTime, \"FightBetting:INVALID_TIME\");\n    require(startTime >= block.timestamp, \"FightBetting:INVALID_TIME\");\n\n    bettings.push(\n      Betting(fighter1, fighter2, minAmount, maxAmount, startTime, endTime, msg.sender, tokenAddr)\n    );\n\n    bettingStates.push(BettingState(0, 0, 0, 0, BettingLiveState.Alive, Side.Fighter1));\n    luckyWinnerStates.push(0);\n\n    seedData.push(SeedData(hashedServerSeed, bytes32(0), bytes32(0)));\n\n    emit NewBetting(fighter1, fighter2, startTime, endTime, tokenAddr);\n  }\n\n  // function:    validates create function variables\n  // @return    ture -> valid, false -> invalid\n  function _isCreateParamValid(\n    uint256 fighter1,\n    uint256 fighter2,\n    uint32 startTime,\n    uint32 endTime,\n    uint256 minAmount,\n    uint256 maxAmount,\n    address token,\n    bytes32 hashedServerSeed,\n    Sig calldata sig\n  ) private view returns (bool) {\n    bytes32 messageHash = keccak256(\n      abi.encodePacked(\n        msg.sender,\n        fighter1,\n        fighter2,\n        startTime,\n        endTime,\n        minAmount,\n        maxAmount,\n        token,\n        hashedServerSeed\n      )\n    );\n    bytes32 ethSignedMessageHash = keccak256(\n      abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", messageHash)\n    );\n\n    return hasRole(\"SIGNER\", ecrecover(ethSignedMessageHash, sig.v, sig.r, sig.s));\n  }\n\n  // function:    bet functin\n  // @param   bettingId: id of the betting\n  // @param   side: which side the bettor is betting on\n  // @param   amount: how much the bettor bets\n  function bettOne(\n    uint256 bettingId,\n    Side side,\n    uint256 value\n  ) public canBet(bettingId, value) {\n    uint256 fighter;\n\n    bettors[bettingId].push(Bettor(msg.sender, value, side, false));\n    betted[bettingId][msg.sender] = true;\n    betNumber[msg.sender]++;\n    seedData[bettingId].clientSeed = keccak256(\n      abi.encodePacked(seedData[bettingId].clientSeed, msg.sender, side == Side.Fighter1)\n    );\n\n    if (side == Side.Fighter1) {\n      bettingStates[bettingId].totalAmount1 += value;\n      bettingStates[bettingId].bettorCount1++;\n      fighter = bettings[bettingId].fighter1;\n    } else {\n      bettingStates[bettingId].totalAmount2 += value;\n      bettingStates[bettingId].bettorCount2++;\n      fighter = bettings[bettingId].fighter2;\n    }\n\n    IERC20(bettings[bettingId].token).safeTransferFrom(msg.sender, address(this), value);\n\n    emit Betted(msg.sender, fighter, value);\n  }\n\n  // function:    end the bet\n  // @param   bettingId: id of betting\n  // @param   serverSeed: server seed of this betting\n  // @param   result: which side was win in this game\n  // @param   sig: signer signature for the access\n  function finishBetting(\n    uint256 bettingId,\n    bytes32 serverSeed,\n    Side result,\n    Sig calldata sig\n  ) public onlyRole(\"MAINTAINER\") {\n    require(_isFinishParamValid(bettingId, serverSeed, result, sig), \"FightBetting:INVALID_PARAM\");\n    require(block.timestamp > bettings[bettingId].endTime, \"FightBetting:TIME_YET\");\n    // require(bettings[bettingId].creator == msg.sender, \"FightBetting:PERMISSION_ERROR\");\n    require(\n      keccak256(abi.encodePacked(bool(result == Side.Fighter1), serverSeed)) ==\n        seedData[bettingId].hashedServerSeed,\n      \"FightBtting:INVALID_SEED\"\n    );\n\n    bettingStates[bettingId].liveState = BettingLiveState.Finished;\n    bettingStates[bettingId].side = result;\n    seedData[bettingId].serverSeed = serverSeed;\n    uint256 winner;\n\n    uint256 fee = (bettingStates[bettingId].totalAmount1 + bettingStates[bettingId].totalAmount2) /\n      20;\n\n    tokenAmounts[bettings[bettingId].token] += fee;\n\n    if (bettingStates[bettingId].side == Side.Fighter1) {\n      winner = bettings[bettingId].fighter1;\n    } else {\n      winner = bettings[bettingId].fighter2;\n    }\n\n    IERC20(bettings[bettingId].token).safeTransfer(jackpotAddr, fee);\n\n    emit Finished(bettingId, winner);\n  }\n\n  // function:    validate the betting parameters\n  // @return    ture -> valid, false -> invalid\n  function _isFinishParamValid(\n    uint256 bettingId,\n    bytes32 serverSeed,\n    Side result,\n    Sig calldata sig\n  ) private view returns (bool) {\n    bytes32 messageHash = keccak256(\n      abi.encodePacked(msg.sender, bettingId, serverSeed, bool(result == Side.Fighter1))\n    );\n    bytes32 ethSignedMessageHash = keccak256(\n      abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", messageHash)\n    );\n\n    return hasRole(\"SIGNER\", ecrecover(ethSignedMessageHash, sig.v, sig.r, sig.s));\n  }\n\n  // function:    returns bettingstate struct of betting which id is bettingId\n  // @param   bettingId: id of betting\n  // @param   betting state\n  function getBettingState(uint256 bettingId) public view returns (BettingState memory betting) {\n    betting = bettingStates[bettingId];\n  }\n\n  // function:    returns bettingresult of betting which id is bettingId\n  // @param   bettingId: id of betting\n  // @return  array of betting result\n  function bettingResult(uint256 bettingId) public view returns (ResultData[] memory) {\n    require(\n      bettingStates[bettingId].liveState == BettingLiveState.Finished,\n      \"FighterBetting:NOT_FINISHED\"\n    );\n\n    uint256 totalBettorCount = bettingStates[bettingId].bettorCount1 +\n      bettingStates[bettingId].bettorCount2;\n    uint256 totalReward = ((bettingStates[bettingId].totalAmount1 +\n      bettingStates[bettingId].totalAmount2) * 88) / 100;\n    uint256 betPrice = bettingStates[bettingId].side == Side.Fighter1\n      ? bettingStates[bettingId].totalAmount1\n      : bettingStates[bettingId].totalAmount2;\n    ResultData[] memory results = new ResultData[](totalBettorCount);\n\n    uint256 j = 0;\n    for (uint256 i = 0; i < bettors[bettingId].length && j < totalBettorCount; i++) {\n      results[j] = ResultData(bettors[bettingId][i].bettor, bettors[bettingId][i].amount, 0);\n      if (bettors[bettingId][i].side == bettingStates[bettingId].side) {\n        results[j].reward = int256(\n          ((totalReward - betPrice) * bettors[bettingId][i].amount) / betPrice\n        );\n      } else {\n        results[j].reward = -1 * int256(bettors[bettingId][i].amount);\n      }\n      j++;\n    }\n    return results;\n  }\n\n  // function:    get bets from 'from' to 'from - number'\n  // @param   from: start betting id\n  // @param   number: number of betting\n  // @return  array of betting data\n  function getPrevFinishedBets(uint256 from, uint256 number)\n    public\n    view\n    returns (Betting[] memory)\n  {\n    Betting[] memory results = new Betting[](number);\n\n    uint256 j = 0;\n    for (uint256 i = from; i >= 0 && j < number; i--) {\n      if (bettingStates[i].liveState == BettingLiveState.Alive) {\n        results[j] = bettings[i];\n        j++;\n      }\n    }\n\n    return results;\n  }\n\n  // function:    get bets from 'from' to 'from + number'\n  // @param   from: start betting id\n  // @param   number: number of betting\n  // @return  array of betting data\n  function getNextFinishedBets(uint256 from, uint256 number)\n    public\n    view\n    returns (Betting[] memory)\n  {\n    Betting[] memory results = new Betting[](number);\n\n    uint256 j = 0;\n    for (uint256 i = from; i >= 0 && j < number; i++) {\n      if (bettingStates[i].liveState == BettingLiveState.Alive) {\n        results[j] = bettings[i];\n        j++;\n      }\n    }\n\n    return results;\n  }\n\n  // function:    withdraw earned money\n  // @param:    token: address of token\n  function withdraw(address token) public onlyOwner {\n    uint256 amount = tokenAmounts[token];\n    tokenAmounts[token] = 0;\n    IERC20(token).safeTransfer(msg.sender, amount);\n  }\n\n  // function:    return bettor id in bettors array\n  // @param   bettingId: id of betting\n  // @return  index of bettor\n  function getBettorIndex(uint256 bettingId) public view returns (uint256) {\n    require(betted[bettingId][msg.sender] == true, \"FightBetting:DID'T_BET\");\n    uint256 totalBettor = bettingStates[bettingId].bettorCount1 +\n      bettingStates[bettingId].bettorCount2;\n    for (uint256 i = 0; i < totalBettor; i++) {\n      if (bettors[bettingId][i].bettor == msg.sender) {\n        return i;\n      }\n    }\n    return 0;\n  }\n\n  // function:    reward result of betting\n  // @param   bettingId: id of betting\n  // @param   index: index of bettor in this betting\n  function withdrawReward(uint256 bettingId, uint256 index) public {\n    require(\n      bettingStates[bettingId].liveState == BettingLiveState.Finished,\n      \"FightBetting:NOT_FINISHED\"\n    );\n    require(betted[bettingId][msg.sender] == true, \"FightBetting:DID'T_BET\");\n    require(bettors[bettingId][index].bettor == msg.sender, \"FightBetting:NOT_BETTOR\");\n    require(\n      bettors[bettingId][index].side == bettingStates[bettingId].side,\n      \"FightBetting:DIDN'T_WINNER\"\n    );\n    require(!bettors[bettingId][index].hasWithdrawn, \"FightBetting:ALREADY_WITHDRAWED\");\n    bettors[bettingId][index].hasWithdrawn = true;\n    // calculate withdraw amount\n    uint256 totalAmount = ((bettingStates[bettingId].totalAmount1 +\n      bettingStates[bettingId].totalAmount2) * 88) / 100;\n\n    uint256 winnerAmount = bettingStates[bettingId].side == Side.Fighter1\n      ? bettingStates[bettingId].totalAmount1\n      : bettingStates[bettingId].totalAmount1;\n\n    uint256 rewardAmount = (totalAmount * bettors[bettingId][index].amount) / winnerAmount;\n    IERC20(bettings[bettingId].token).safeTransfer(msg.sender, rewardAmount);\n\n    emit WinnerWithdrawed(bettingId, msg.sender, totalAmount);\n    return;\n  }\n\n  // For provably.\n\n  // function:    return hash of server seed\n  // @param   bettingId: id of betting\n  // @return  hashed server seed\n  function getServerSeedHash(uint256 bettingId) public view returns (bytes32) {\n    return seedData[bettingId].hashedServerSeed;\n  }\n\n  // function:    return client seed\n  // @param   bettingId: id of betting\n  // @return  client seed\n  function getClientSeed(uint256 bettingId) public view returns (bytes32) {\n    return seedData[bettingId].clientSeed;\n  }\n\n  // function:    return server seed\n  // @param   bettingId: id of betting\n  // @return  server seed\n  function getServerSeed(uint256 bettingId) public view returns (bytes32) {\n    require(\n      bettingStates[bettingId].liveState == BettingLiveState.Finished,\n      \"FightBetting:NOT_FINISHED\"\n    );\n\n    return seedData[bettingId].serverSeed;\n  }\n\n  // function:    return bettor data\n  // @param   bettingId: id of betting\n  // @param   bettorId: id of bettor in this betting\n  // @return  bettor data\n  function getBettorData(uint256 bettingId, uint256 bettorId) public view returns (Bettor memory) {\n    return bettors[bettingId][bettorId];\n  }\n\n  // function:    returns winner bettor ids\n  // @param   bettingId: id of betting\n  // @return  ids: array of ids who winned\n  function getWinBettorIds(uint256 bettingId) public view returns (uint256[] memory ids) {\n    require(\n      bettingStates[bettingId].liveState == BettingLiveState.Finished,\n      \"FightBetting:NOT_FINISHED\"\n    );\n\n    uint256 total = bettingStates[bettingId].side == Side.Fighter1\n      ? bettingStates[bettingId].bettorCount1\n      : bettingStates[bettingId].bettorCount2;\n\n    ids = new uint256[](total);\n\n    uint256 j = 0;\n    for (uint256 i = 0; j < total && i < bettors[bettingId].length; i++) {\n      if (bettors[bettingId][i].side == bettingStates[bettingId].side) {\n        ids[j] = i;\n        j++;\n      }\n    }\n  }\n\n  // function:    return address and reward of lucky winner\n  // @param   bettingId: id of betting\n  // @retrun  winners: array of winner address\n  // @return  rewards: array of rewards\n  function getLuckyWinner(uint256 bettingId)\n    public\n    view\n    returns (address[] memory winners, uint256[] memory rewards)\n  {\n    require(\n      bettingStates[bettingId].liveState == BettingLiveState.Finished,\n      \"FightBetting:NOT_FINISHED\"\n    );\n\n    require(betted[bettingId][msg.sender], \"FightBetting:DIDNT_BETTED\");\n\n    // get bettor data\n    Bettor memory bettor;\n\n    for (uint256 i = 0; i < bettors[bettingId].length; i++) {\n      if (bettors[bettingId][i].bettor == msg.sender) {\n        bettor = bettors[bettingId][i];\n        break;\n      }\n    }\n\n    require(bettingStates[bettingId].side == bettor.side, \"FightBetting:LOSS\");\n\n    // hash seeds;\n    uint256 winnerBettorCount = bettingStates[bettingId].side == Side.Fighter1\n      ? bettingStates[bettingId].bettorCount1\n      : bettingStates[bettingId].bettorCount2;\n    uint256 luckyWinnerRewardAmount = ((bettingStates[bettingId].totalAmount1 +\n      bettingStates[bettingId].totalAmount2) * 2) / 100;\n\n    bytes32 hashed = keccak256(\n      abi.encodePacked(\n        seedData[bettingId].serverSeed,\n        seedData[bettingId].clientSeed,\n        winnerBettorCount,\n        luckyWinnerRewardAmount\n      )\n    );\n\n    uint256 goldIndex = uint256(hashed) % winnerBettorCount;\n    uint256 silverIndex;\n    uint256 bronzeIndex;\n\n    hashed = keccak256(\n      abi.encodePacked(\n        hashed,\n        seedData[bettingId].serverSeed,\n        seedData[bettingId].clientSeed,\n        winnerBettorCount,\n        luckyWinnerRewardAmount\n      )\n    );\n    silverIndex = uint256(hashed) % winnerBettorCount;\n\n    hashed = keccak256(\n      abi.encodePacked(\n        hashed,\n        seedData[bettingId].serverSeed,\n        seedData[bettingId].clientSeed,\n        winnerBettorCount,\n        luckyWinnerRewardAmount\n      )\n    );\n    bronzeIndex = uint256(hashed) % winnerBettorCount;\n\n    winners = new address[](3);\n    rewards = new uint256[](3);\n    // gold winner\n    winners[0] = bettors[bettingId][goldIndex].bettor;\n    rewards[0] = (luckyWinnerRewardAmount * 5) / 8;\n\n    // silver medal\n    winners[1] = bettors[bettingId][silverIndex].bettor;\n    rewards[1] = luckyWinnerRewardAmount / 4;\n\n    // bronze medal\n    winners[2] = bettors[bettingId][bronzeIndex].bettor;\n    rewards[2] = luckyWinnerRewardAmount - rewards[0] - rewards[1];\n  }\n\n  // function:    withdraw reward of lucky winner\n  // @param   bettingId: id of betting\n  function withdrawLuckyWinnerReward(uint256 bettingId) public {\n    address[] memory winners;\n    uint256[] memory rewards;\n    (winners, rewards) = getLuckyWinner(bettingId);\n\n    if (winners[0] == msg.sender) {\n      require(luckyWinnerStates[bettingId] & 0x01 == 0, \"FightBetting:ALREADY_WITHDRAWD\");\n      luckyWinnerStates[bettingId] += 0x01;\n      IERC20(bettings[bettingId].token).safeTransfer(msg.sender, rewards[0]);\n    }\n\n    if (winners[1] == msg.sender) {\n      require(luckyWinnerStates[bettingId] & 0x02 == 0, \"FightBetting:ALREADY_WITHDRAWD\");\n      luckyWinnerStates[bettingId] += 0x02;\n      IERC20(bettings[bettingId].token).safeTransfer(msg.sender, rewards[1]);\n    }\n\n    if (winners[2] == msg.sender) {\n      require(luckyWinnerStates[bettingId] & 0x04 == 0, \"FightBetting:ALREADY_WITHDRAWD\");\n      luckyWinnerStates[bettingId] += 0x04;\n      IERC20(bettings[bettingId].token).safeTransfer(msg.sender, rewards[2]);\n    }\n  }\n\n  // JackPot\n\n  // function:    set jackpot address\n  // @param   jackpot: address of jackpot\n  function setJackPot(address jackpot) public onlyOwner {\n    jackpotAddr = jackpot;\n  }\n\n  // function:    return minimum bet count for jackpot ticket\n  // @return: jackpot amount can get\n  function jackPotNFTAmount() public view returns (uint256 amount) {\n    amount = betNumber[msg.sender] / minBetNumForJackPot;\n  }\n\n  // function:    get jackpot tickets from bet\n  // @return: jackpot ticket amount\n  function getJackPotNFT() public returns (uint256 amount) {\n    amount = jackPotNFTAmount();\n    require(amount > 0, \"FightBetting:NOT_ENOUGH\");\n\n    betNumber[msg.sender] -= minBetNumForJackPot * amount;\n    IJackPot(jackpotAddr).mintTo(amount, msg.sender);\n  }\n\n  // function:    sets minimum bet count for jackpot ticket\n  // @param   min: minimum bet count for jackpot ticket\n  function setJackPotMin(uint256 min) public onlyOwner {\n    minBetNumForJackPot = min;\n  }\n\n  // function:    set token for create betting with this token\n  // @param:    token: address of tokenAddress\n  // @param:    value: true-allow, false-reject\n  function setTokenAllowance(address tokenAddress, bool value) public onlyOwner {\n    allowedTokens[tokenAddress] = value;\n  }\n}\n"
    },
    "contracts/betting/IFightBetting.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.9;\n\ninterface IFightBetting {\n  // current betting live state\n  enum BettingLiveState {\n    Alive,\n    Finished\n  }\n  // which player bet\n  enum Side {\n    Fighter1,\n    Fighter2\n  }\n  // betting data\n  struct Betting {\n    uint256 fighter1; // First Fighter's token id\n    uint256 fighter2; // Second Fighter's token id\n    uint256 minAmount; // Minimum value of amount\n    uint256 maxAmount; // Maximum value of amount\n    uint32 startTime; // Start time of betting\n    uint32 endTime; // End time of betting\n    address creator; // Creator of betting\n    address token; // Payable token address\n  }\n  // betting states\n  struct BettingState {\n    uint256 bettorCount1; // Count of bettor who bet first Fighter\n    uint256 bettorCount2; // Count of bettor who bet second Fighter\n    uint256 totalAmount1; // Total price of first Fighter bettors\n    uint256 totalAmount2; // Total price of second Fighter bettors\n    BettingLiveState liveState; // Set true after finish betting\n    Side side; // who has winned\n  }\n  // bettor data\n  struct Bettor {\n    address bettor; // Address of bettor\n    uint256 amount; // Deposit amount\n    Side side; // which betted\n    bool hasWithdrawn; // has withdrawn?\n  }\n  // signature struct\n  struct Sig {\n    bytes32 r;\n    bytes32 s;\n    uint8 v;\n  }\n  // game result struct\n  struct ResultData {\n    address bettor;\n    uint256 amount;\n    int256 reward; // Winner true => fighter1 | false => fighter2\n  }\n  // seed data of game\n  struct SeedData {\n    bytes32 hashedServerSeed;\n    bytes32 serverSeed;\n    bytes32 clientSeed;\n  }\n\n  // Events\n  // emit when new betting is created\n  event NewBetting(\n    uint256 fighter1,\n    uint256 fighter2,\n    uint32 startTime,\n    uint32 endTime,\n    address token\n  );\n  // emit when bettor bet a player(fighter)\n  event Betted(address indexed from, uint256 fighter, uint256 amount);\n  // emit when betting is finished\n  event Finished(uint256 bettingId, uint256 winner);\n  // emit when bettor withdraw their reward\n  event WinnerWithdrawed(uint256 bettingId, address indexed to, uint256 amount);\n}\n"
    },
    "contracts/mocks/MockVRFCoordinatorV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// A mock for testing code that relies on VRFCoordinatorV2.\npragma solidity ^0.8.0;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol\";\nimport \"@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol\";\n\ncontract MockVRFCoordinatorV2 is VRFCoordinatorV2Interface {\n  uint96 public immutable BASE_FEE;\n  uint96 public immutable GAS_PRICE_LINK;\n\n  error InvalidSubscription();\n  error InsufficientBalance();\n  error MustBeSubOwner(address owner);\n\n  event RandomWordsRequested(\n    bytes32 indexed keyHash,\n    uint256 requestId,\n    uint256 preSeed,\n    uint64 indexed subId,\n    uint16 minimumRequestConfirmations,\n    uint32 callbackGasLimit,\n    uint32 numWords,\n    address indexed sender\n  );\n  event RandomWordsFulfilled(\n    uint256 indexed requestId,\n    uint256 outputSeed,\n    uint96 payment,\n    bool success\n  );\n  event SubscriptionCreated(uint64 indexed subId, address owner);\n  event SubscriptionFunded(uint64 indexed subId, uint256 oldBalance, uint256 newBalance);\n  event SubscriptionCanceled(uint64 indexed subId, address to, uint256 amount);\n\n  uint64 s_currentSubId;\n  uint256 s_nextRequestId = 1;\n  uint256 s_nextPreSeed = 100;\n  struct Subscription {\n    address owner;\n    uint96 balance;\n  }\n  mapping(uint64 => Subscription) s_subscriptions; /* subId */ /* subscription */\n\n  struct Request {\n    uint64 subId;\n    uint32 callbackGasLimit;\n    uint32 numWords;\n  }\n  mapping(uint256 => Request) s_requests; /* requestId */ /* request */\n\n  constructor(uint96 _baseFee, uint96 _gasPriceLink) {\n    BASE_FEE = _baseFee;\n    GAS_PRICE_LINK = _gasPriceLink;\n  }\n\n  /**\n   * @notice fulfillRandomWords fulfills the given request, sending the random words to the supplied\n   * @notice consumer.\n   *\n   * @dev This mock uses a simplified formula for calculating payment amount and gas usage, and does\n   * @dev not account for all edge cases handled in the real VRF coordinator. When making requests\n   * @dev against the real coordinator a small amount of additional LINK is required.\n   *\n   * @param _requestId the request to fulfill\n   * @param _consumer the VRF randomness consumer to send the result to\n   */\n  function fulfillRandomWords(uint256 _requestId, address _consumer) external {\n    uint256 startGas = gasleft();\n    if (s_requests[_requestId].subId == 0) {\n      revert(\"nonexistent request\");\n    }\n    Request memory req = s_requests[_requestId];\n\n    uint256[] memory words = new uint256[](req.numWords);\n    for (uint256 i = 0; i < req.numWords; i++) {\n      words[i] = uint256(keccak256(abi.encode(_requestId, i)));\n    }\n\n    VRFConsumerBaseV2 v;\n    bytes memory callReq = abi.encodeWithSelector(\n      v.rawFulfillRandomWords.selector,\n      _requestId,\n      words\n    );\n    (bool success, ) = _consumer.call{gas: req.callbackGasLimit}(callReq);\n\n    // uint96 payment = uint96(BASE_FEE + ((startGas - gasleft()) * GAS_PRICE_LINK));\n    uint96 payment = 0;\n    if (s_subscriptions[req.subId].balance < payment) {\n      revert InsufficientBalance();\n    }\n    s_subscriptions[req.subId].balance -= payment;\n    delete (s_requests[_requestId]);\n    emit RandomWordsFulfilled(_requestId, _requestId, payment, success);\n  }\n\n  /**\n   * @notice fundSubscription allows funding a subscription with an arbitrary amount for testing.\n   *\n   * @param _subId the subscription to fund\n   * @param _amount the amount to fund\n   */\n  function fundSubscription(uint64 _subId, uint96 _amount) public {\n    if (s_subscriptions[_subId].owner == address(0)) {\n      revert InvalidSubscription();\n    }\n    uint96 oldBalance = s_subscriptions[_subId].balance;\n    s_subscriptions[_subId].balance += _amount;\n    emit SubscriptionFunded(_subId, oldBalance, oldBalance + _amount);\n  }\n\n  function requestRandomWords(\n    bytes32 _keyHash,\n    uint64 _subId,\n    uint16 _minimumRequestConfirmations,\n    uint32 _callbackGasLimit,\n    uint32 _numWords\n  ) external override returns (uint256) {\n    if (s_subscriptions[_subId].owner == address(0)) {\n      revert InvalidSubscription();\n    }\n\n    uint256 requestId = s_nextRequestId++;\n    uint256 preSeed = s_nextPreSeed++;\n\n    s_requests[requestId] = Request({\n      subId: _subId,\n      callbackGasLimit: _callbackGasLimit,\n      numWords: _numWords\n    });\n\n    emit RandomWordsRequested(\n      _keyHash,\n      requestId,\n      preSeed,\n      _subId,\n      _minimumRequestConfirmations,\n      _callbackGasLimit,\n      _numWords,\n      msg.sender\n    );\n    return requestId;\n  }\n\n  function createSubscription() external override returns (uint64 _subId) {\n    s_currentSubId++;\n    s_subscriptions[s_currentSubId] = Subscription({owner: msg.sender, balance: 0});\n    emit SubscriptionCreated(s_currentSubId, msg.sender);\n    return s_currentSubId;\n  }\n\n  function getSubscription(uint64 _subId)\n    external\n    view\n    override\n    returns (\n      uint96 balance,\n      uint64 reqCount,\n      address owner,\n      address[] memory consumers\n    )\n  {\n    if (s_subscriptions[_subId].owner == address(0)) {\n      revert InvalidSubscription();\n    }\n    return (s_subscriptions[_subId].balance, 0, s_subscriptions[_subId].owner, new address[](0));\n  }\n\n  function cancelSubscription(uint64 _subId, address _to) external override onlySubOwner(_subId) {\n    emit SubscriptionCanceled(_subId, _to, s_subscriptions[_subId].balance);\n    delete (s_subscriptions[_subId]);\n  }\n\n  modifier onlySubOwner(uint64 _subId) {\n    address owner = s_subscriptions[_subId].owner;\n    if (owner == address(0)) {\n      revert InvalidSubscription();\n    }\n    if (msg.sender != owner) {\n      revert MustBeSubOwner(owner);\n    }\n    _;\n  }\n\n  function getRequestConfig()\n    external\n    pure\n    override\n    returns (\n      uint16,\n      uint32,\n      bytes32[] memory\n    )\n  {\n    return (3, 2000000, new bytes32[](0));\n  }\n\n  function addConsumer(uint64 _subId, address _consumer) external pure override {\n    revert(\"not implemented\");\n  }\n\n  function removeConsumer(uint64 _subId, address _consumer) external pure override {\n    revert(\"not implemented\");\n  }\n\n  function requestSubscriptionOwnerTransfer(uint64 _subId, address _newOwner)\n    external\n    pure\n    override\n  {\n    revert(\"not implemented\");\n  }\n\n  function acceptSubscriptionOwnerTransfer(uint64 _subId) external pure override {\n    revert(\"not implemented\");\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface LinkTokenInterface {\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n  function approve(address spender, uint256 value) external returns (bool success);\n\n  function balanceOf(address owner) external view returns (uint256 balance);\n\n  function decimals() external view returns (uint8 decimalPlaces);\n\n  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\n\n  function increaseApproval(address spender, uint256 subtractedValue) external;\n\n  function name() external view returns (string memory tokenName);\n\n  function symbol() external view returns (string memory tokenSymbol);\n\n  function totalSupply() external view returns (uint256 totalTokensIssued);\n\n  function transfer(address to, uint256 value) external returns (bool success);\n\n  function transferAndCall(\n    address to,\n    uint256 value,\n    bytes calldata data\n  ) external returns (bool success);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  ) external returns (bool success);\n}\n"
    },
    "contracts/gwit/gwit.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.2;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";\n\ncontract GWITToken is ERC20Permit, Ownable {\n  address private constant _BURN_ADDRESS = 0x0000000000000000000000000000000000001337;\n  address public farm_pool;\n  address public grp;\n\n  bool private _init;\n  event Initialized();\n\n  uint256 public initialSupply;\n\n  address public tax_address;\n  mapping(address => uint256) private tax_table;\n  event Taxed(address from, address to, uint256 tax_amount);\n\n  constructor(uint256 _initialSupply) ERC20Permit(\"GWIT\") ERC20(\"GWIT\", \"GWIT\") {\n    initialSupply = _initialSupply * 1e18;\n  }\n\n  function init(address _grp, address _farm_pool) public onlyOwner {\n    require(!_init, \"already initialized\");\n    require(_grp != address(0) && _farm_pool != address(0), \"invalid init address\");\n    grp = _grp;\n    farm_pool = _farm_pool;\n\n    // token distribution\n    _mint(grp, (initialSupply * 46) / 100); // 46%\n    _mint(farm_pool, (initialSupply * 10) / 100); // 10%\n    _mint(msg.sender, (initialSupply * 44) / 100); // 44%\n\n    _init = true;\n    emit Initialized();\n  }\n\n  function burn(uint256 amount) public {\n    transfer(_BURN_ADDRESS, amount);\n  }\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 amount\n  ) public override returns (bool) {\n    // keeps track of the last time the msg\n    if (taxRate(to) != 0) {\n      require(amount != 0, \"amount should be > 0\");\n      uint256 tax = calcTaxRate(to, amount);\n      amount -= tax;\n\n      // send the taxed tokens to the tax_address\n      ERC20._transfer(from, tax_address, tax);\n      _spendAllowance(from, msg.sender, tax);\n      emit Taxed(from, to, tax);\n    }\n\n    return ERC20.transferFrom(from, to, amount);\n  }\n\n  // set the tax rate for future approvals. minium 1 = 0.01% e.g. 525 = 5.25% tax rate\n  function setTaxRate(address target, uint256 _tax_Rate) public onlyOwner {\n    tax_table[target] = _tax_Rate;\n  }\n\n  // set the address to where the tax gets transfered for tax\n  function setTaxAddress(address _tax_address) public onlyOwner {\n    tax_address = _tax_address;\n  }\n\n  function taxRate(address to) public view returns (uint256) {\n    return tax_table[to];\n  }\n\n  function calcTaxRate(address to, uint256 amount) public view returns (uint256) {\n    if (taxRate(to) == 0) {\n      return 0;\n    }\n    return (amount * taxRate(to)) / 10_000;\n  }\n}\n"
    },
    "contracts/gwit/grp.sol": {
      "content": "/**\n    Game Rewards Pool or (GRP) handles the claiming of rewards from the game to the chain\n    It facilitates $GALL to $GWIT conversion\n */\n// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\ncontract GRP is Ownable {\n  address public _token;\n  mapping(uint256 => bool) public burned;\n  using SafeERC20 for IERC20;\n\n  event Claimed(uint256 indexed nonce, address indexed target, uint256 amount);\n  struct Claim {\n    uint256 nonce;\n    address target;\n    uint256 amount;\n    Sig signature;\n  }\n\n  address public signer;\n  event UpdateSigner(address indexed signer);\n  struct Sig {\n    bytes32 r;\n    bytes32 s;\n    uint8 v;\n  }\n\n  constructor(address _signer) {\n    setSigner(_signer);\n  }\n\n  function setSigner(address newSigner) public onlyOwner {\n    signer = newSigner;\n    emit UpdateSigner(signer);\n  }\n\n  function authorize(Sig calldata sig, bytes32 messageHash) internal view returns (bool) {\n    bytes32 ethSignedMessageHash = keccak256(\n      abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", messageHash)\n    );\n    return ecrecover(ethSignedMessageHash, sig.v, sig.r, sig.s) == signer;\n  }\n\n  // run once\n  function setTokenAddr(address addr) external onlyOwner {\n    require(_token == address(0), \"token address is 0\");\n    _token = addr;\n  }\n\n  function tokenAddr() public view returns (address) {\n    return _token;\n  }\n\n  function validateClaim(Claim calldata claimData) public view returns (bool) {\n    require(claimData.amount > 0, \"cannot claim <0\");\n    // Validation\n    require(!burned[claimData.nonce], \"claim already burned\");\n\n    bytes32 messageHash = keccak256(\n      abi.encodePacked(claimData.nonce, claimData.target, claimData.amount)\n    );\n    return authorize(claimData.signature, messageHash);\n  }\n\n  function claim(Claim calldata claimData) public {\n    // bytes32 messageHash = keccak256(abi.encodePacked(claimData.nonce, claimData.target, claimData.amount));\n    require(validateClaim(claimData), \"invalid signature\");\n\n    // Transfer\n    IERC20 token = IERC20(_token);\n    token.safeTransfer(claimData.target, claimData.amount);\n\n    // Cleanup\n    burned[claimData.nonce] = true;\n    emit Claimed(claimData.nonce, claimData.target, claimData.amount);\n  }\n\n  function reserves() public view returns (uint256) {\n    IERC20 token = IERC20(_token);\n    return token.balanceOf(address(this));\n  }\n}\n"
    },
    "contracts/gem/GemMetadata.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.9;\n\nimport {ERC721} from \"@rari-capital/solmate/src/tokens/ERC721.sol\";\nimport {Strings} from \"@openzeppelin/contracts/utils/Strings.sol\";\nimport {Auth} from \"../utils/Auth.sol\";\n\nabstract contract GemMetadata is ERC721, Auth {\n  using Strings for uint256;\n\n  //Gem metadata base uri\n  string private _baseUri;\n  //Maps gem id to gem types\n  mapping(uint256 => uint256) private _gemTypes;\n\n  //Fires when base uri is updated\n  event UpdateBaseUri(string baseUri);\n  //Fires when gem type is set\n  event GemTypeSet(uint256 indexed gemId, uint256 gemType);\n\n  function gemTypes(uint256 gemId) public view returns (uint256) {\n    require(_exists(gemId), \"Query for nonexistent gem\");\n    return _gemTypes[gemId];\n  }\n\n  function tokenURI(uint256 gemId) public view override returns (string memory) {\n    require(_exists(gemId), \"Query for nonexistent gem\");\n    return string(abi.encodePacked(_baseUri, gemId.toString()));\n  }\n\n  function setBaseUri(string memory newUri) public onlyOwner {\n    _baseUri = newUri;\n    emit UpdateBaseUri(newUri);\n  }\n\n  function _setGemType(uint256 gemId, uint256 gemType) internal {\n    _gemTypes[gemId] = gemType;\n    emit GemTypeSet(gemId, gemType);\n  }\n\n  function _exists(uint256 tokenId) internal view returns (bool) {\n    return ownerOf[tokenId] != address(0);\n  }\n}\n"
    },
    "contracts/rooster/Rooster.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.9;\n\nimport {ERC721} from \"@rari-capital/solmate/src/tokens/ERC721.sol\";\nimport {RoosterMetadata} from \"./RoosterMetadata.sol\";\nimport {Auth} from \"../utils/Auth.sol\";\n\ncontract Rooster is ERC721, Auth, RoosterMetadata {\n  //Current roosterId count\n  uint256 private _roosterIdCounter = 0;\n\n  constructor(string memory baseUri_) ERC721(\"Rooster\", \"ROOSTER\") {\n    setBaseUri(baseUri_);\n  }\n\n  function totalSupply() public view returns (uint256) {\n    return _roosterIdCounter;\n  }\n\n  function safeBatchTransferFrom(\n    address from,\n    address to,\n    uint256[] memory roosterIds\n  ) external {\n    for (uint256 i = 0; i < roosterIds.length; ) {\n      safeTransferFrom(from, to, roosterIds[i]);\n      unchecked {\n        i++;\n      }\n    }\n  }\n\n  function mint(address to, uint256 breed) external onlyRole(\"MINTER\") {\n    uint256 roosterId = _roosterIdCounter;\n\n    unchecked {\n      _roosterIdCounter++;\n    }\n\n    _mint(to, roosterId, breed);\n  }\n\n  function batchMint(address to, uint256[] memory breeds) external onlyRole(\"MINTER\") {\n    uint256 roosterId = _roosterIdCounter;\n\n    for (uint256 i = 0; i < breeds.length; ) {\n      _mint(to, roosterId, breeds[i]);\n\n      unchecked {\n        roosterId++;\n        i++;\n      }\n    }\n\n    _roosterIdCounter = roosterId;\n  }\n\n  function _mint(\n    address to,\n    uint256 roosterId,\n    uint256 breed\n  ) private {\n    _safeMint(to, roosterId);\n    _setBreed(roosterId, breed);\n  }\n}\n"
    },
    "contracts/gem/Gem.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.9;\n\nimport {ERC721} from \"@rari-capital/solmate/src/tokens/ERC721.sol\";\nimport {GemMetadata} from \"./GemMetadata.sol\";\nimport {Auth} from \"../utils/Auth.sol\";\n\ncontract Gem is ERC721, Auth, GemMetadata {\n  //Current gemId count\n  uint256 private _gemIdCounter = 0;\n\n  constructor(string memory baseUri_) ERC721(\"Gem\", \"GEM\") {\n    setBaseUri(baseUri_);\n  }\n\n  function totalSupply() public view returns (uint256) {\n    return _gemIdCounter;\n  }\n\n  function safeBatchTransferFrom(\n    address from,\n    address to,\n    uint256[] memory gemIds\n  ) external {\n    for (uint256 i = 0; i < gemIds.length; ) {\n      safeTransferFrom(from, to, gemIds[i]);\n      unchecked {\n        i++;\n      }\n    }\n  }\n\n  function mint(address to, uint256 gemType) external onlyRole(\"MINTER\") {\n    uint256 gemId = _gemIdCounter;\n\n    unchecked {\n      _gemIdCounter++;\n    }\n\n    _mint(to, gemId, gemType);\n  }\n\n  function batchMint(address to, uint256[] memory gemTypes) external onlyRole(\"MINTER\") {\n    uint256 gemId = _gemIdCounter;\n\n    for (uint256 i = 0; i < gemTypes.length; ) {\n      _mint(to, gemId, gemTypes[i]);\n\n      unchecked {\n        gemId++;\n        i++;\n      }\n    }\n\n    _gemIdCounter = gemId;\n  }\n\n  function _mint(\n    address to,\n    uint256 gemId,\n    uint256 gemType\n  ) private {\n    _safeMint(to, gemId);\n    _setGemType(gemId, gemType);\n  }\n}\n"
    },
    "contracts/gaff/GaffMetadata.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.9;\n\nimport {ERC721} from \"@rari-capital/solmate/src/tokens/ERC721.sol\";\nimport {Strings} from \"@openzeppelin/contracts/utils/Strings.sol\";\nimport {Auth} from \"../utils/Auth.sol\";\n\nabstract contract GaffMetadata is ERC721, Auth {\n  using Strings for uint256;\n\n  //Gaff metadata base uri\n  string private _baseUri;\n  //Maps gaff id to gaff types\n  mapping(uint256 => uint256) private _gaffTypes;\n\n  //Fires when base uri is updated\n  event UpdateBaseUri(string baseUri);\n  //Fires when gaff type is set\n  event GaffTypeSet(uint256 indexed gaffId, uint256 gaffType);\n\n  function gaffTypes(uint256 gaffId) public view returns (uint256) {\n    require(_exists(gaffId), \"Query for nonexistent gaff\");\n    return _gaffTypes[gaffId];\n  }\n\n  function tokenURI(uint256 gaffId) public view override returns (string memory) {\n    require(_exists(gaffId), \"Query for nonexistent gaff\");\n    return string(abi.encodePacked(_baseUri, gaffId.toString()));\n  }\n\n  function setBaseUri(string memory newUri) public onlyOwner {\n    _baseUri = newUri;\n    emit UpdateBaseUri(newUri);\n  }\n\n  function _setGaffType(uint256 gaffId, uint256 gaffType) internal {\n    _gaffTypes[gaffId] = gaffType;\n    emit GaffTypeSet(gaffId, gaffType);\n  }\n\n  function _exists(uint256 tokenId) internal view returns (bool) {\n    return ownerOf[tokenId] != address(0);\n  }\n}\n"
    },
    "contracts/gaff/Gaff.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.9;\n\nimport {ERC721} from \"@rari-capital/solmate/src/tokens/ERC721.sol\";\nimport {GaffMetadata} from \"./GaffMetadata.sol\";\nimport {Auth} from \"../utils/Auth.sol\";\n\ncontract Gaff is ERC721, Auth, GaffMetadata {\n  //Current gaffId count\n  uint256 private _gaffIdCounter = 0;\n\n  constructor(string memory baseUri_) ERC721(\"Gaff\", \"GAFF\") {\n    setBaseUri(baseUri_);\n  }\n\n  function totalSupply() public view returns (uint256) {\n    return _gaffIdCounter;\n  }\n\n  function safeBatchTransferFrom(\n    address from,\n    address to,\n    uint256[] memory gaffIds\n  ) external {\n    for (uint256 i = 0; i < gaffIds.length; ) {\n      safeTransferFrom(from, to, gaffIds[i]);\n      unchecked {\n        i++;\n      }\n    }\n  }\n\n  function mint(address to, uint256 gaffType) external onlyRole(\"MINTER\") {\n    uint256 gaffId = _gaffIdCounter;\n\n    unchecked {\n      _gaffIdCounter++;\n    }\n\n    _mint(to, gaffId, gaffType);\n  }\n\n  function batchMint(address to, uint256[] memory gaffTypes) external onlyRole(\"MINTER\") {\n    uint256 gaffId = _gaffIdCounter;\n\n    for (uint256 i = 0; i < gaffTypes.length; ) {\n      _mint(to, gaffId, gaffTypes[i]);\n\n      unchecked {\n        gaffId++;\n        i++;\n      }\n    }\n\n    _gaffIdCounter = gaffId;\n  }\n\n  function _mint(\n    address to,\n    uint256 gaffId,\n    uint256 gaffType\n  ) private {\n    _safeMint(to, gaffId);\n    _setGaffType(gaffId, gaffType);\n  }\n}\n"
    },
    "contracts/gwit/AlphaGwit.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport {Auth} from \"../utils/Auth.sol\";\n\ncontract AlphaGwit is Auth {\n  event Transfer(address indexed from, address indexed to, uint256 amount);\n\n  string public constant name = \"AlphaGwit\";\n  string public constant symbol = \"aGWIT\";\n  uint8 public immutable decimals = 18;\n\n  uint256 public totalSupply;\n\n  mapping(address => uint256) public balanceOf;\n\n  function mint(address to, uint256 amount) external onlyRole(\"MINTER\") {\n    totalSupply += amount;\n\n    unchecked {\n      balanceOf[to] += amount;\n    }\n\n    emit Transfer(address(0), to, amount);\n  }\n\n  function burn(uint256 amount) external whenNotPaused {\n    address from = msg.sender;\n    balanceOf[from] -= amount;\n\n    unchecked {\n      totalSupply -= amount;\n    }\n\n    emit Transfer(from, address(0), amount);\n  }\n}\n"
    },
    "contracts/egg/EggHatching.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.9;\n\nimport {Auth} from \"../utils/Auth.sol\";\n\ninterface IEgg {\n  function burnBatch(uint24[] memory eggIds) external;\n\n  function ownerOf(uint256 tokenId) external view returns (address);\n}\n\ninterface INft {\n  function batchMint(address to, uint256[] memory types) external;\n}\n\ncontract RoosterEggHatching is Auth {\n  //Address of RoosterEgg contract\n  address public immutable egg;\n  //Address of Rooster contract\n  address public immutable rooster;\n  //Address of Gaff contract\n  address public immutable gaff;\n  //Address of Gem contract\n  address public immutable gem;\n  //Egg hatch starting time\n  uint256 public startingTime;\n\n  //Fires when eggs are hatched\n  event EggsHatched(address indexed user, uint24[] eggIds);\n\n  struct Sig {\n    bytes32 r;\n    bytes32 s;\n    uint8 v;\n  }\n\n  constructor(\n    address signer_,\n    address egg_,\n    address rooster_,\n    address gaff_,\n    address gem_\n  ) {\n    egg = egg_;\n    rooster = rooster_;\n    gaff = gaff_;\n    gem = gem_;\n    _grantRole(\"SIGNER\", signer_);\n  }\n\n  function hasStarted() public view returns (bool) {\n    return block.timestamp >= startingTime && startingTime > 0 ? true : false;\n  }\n\n  /**\n   * @param eggIds Array of rooster egg ids to burn\n   * @param breeds Array of rooster breeds to mint\n   * @param gaffTypes Array of gaff amounts to mint (Index number corresponds to gaff id)\n   * @param gemTypes Array of gem ids to mint\n   */\n  function hatch(\n    address to,\n    uint24[] calldata eggIds,\n    uint256[] calldata breeds,\n    uint256[] calldata gaffTypes,\n    uint256[] calldata gemTypes,\n    Sig calldata sig\n  ) external whenNotPaused {\n    //Check if hatch event is started\n    require(hasStarted(), \"Not started\");\n    //Check if parameters are valid\n    require(_isParamValid(breeds, gaffTypes, gemTypes, sig), \"Invalid parameter\");\n    //Check if egg owner\n    require(_isOwnerCorrect(eggIds), \"Invalid owner\");\n\n    //Burn eggs\n    IEgg(egg).burnBatch(eggIds);\n    //Mint roosters\n    INft(rooster).batchMint(to, breeds);\n    //Mint gaffs\n    INft(gaff).batchMint(to, gaffTypes);\n    //Mint gems\n    INft(gem).batchMint(to, gemTypes);\n\n    emit EggsHatched(msg.sender, eggIds);\n  }\n\n  function _isParamValid(\n    uint256[] calldata breeds,\n    uint256[] calldata gaffTypes,\n    uint256[] calldata gemTypes,\n    Sig calldata sig\n  ) private view returns (bool) {\n    bytes32 messageHash = keccak256(abi.encodePacked(msg.sender, breeds, gaffTypes, gemTypes));\n    bytes32 ethSignedMessageHash = keccak256(\n      abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", messageHash)\n    );\n\n    return hasRole(\"SIGNER\", ecrecover(ethSignedMessageHash, sig.v, sig.r, sig.s));\n  }\n\n  function _isOwnerCorrect(uint24[] calldata eggIds) private view returns (bool) {\n    unchecked {\n      for (uint256 i = 0; i < eggIds.length; i++) {\n        if (IEgg(egg).ownerOf(eggIds[i]) != msg.sender) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  function setStartingTime(uint256 startingTime_) external onlyOwner {\n    require(startingTime_ > block.timestamp, \"Invalid starting time\");\n    startingTime = startingTime_;\n  }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 9999
    },
    "outputSelection": {
      "*": {
        "*": [
          "storageLayout",
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "libraries": {
      "": {
        "__CACHE_BREAKER__": "0x00000000d41867734bbee4c6863d9255b2b06ac1"
      }
    }
  }
}